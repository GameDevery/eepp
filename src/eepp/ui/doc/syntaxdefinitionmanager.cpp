#include <algorithm>
#include <eepp/system/filesystem.hpp>
#include <eepp/system/luapattern.hpp>
#include <eepp/ui/doc/syntaxdefinitionmanager.hpp>
#include <eepp/ui/uiwidgetcreator.hpp>

using namespace EE::System;

namespace EE { namespace UI { namespace Doc {

SINGLETON_DECLARE_IMPLEMENTATION( SyntaxDefinitionManager )

// Syntax definitions can be directly converted from the lite (https://github.com/rxi/lite) and
// lite-plugins (https://github.com/rxi/lite-plugins) supported languages.

SyntaxDefinitionManager::SyntaxDefinitionManager() {
	// Register some languages support.

	// Plain text
	add( { "Plain Text", { "%.txt$" }, {} } );

	// XML
	add( { "XML",
		   { "%.xml$", "%.svg$" },
		   {
			   { { "<!%-%-", "%-%->" }, "comment" },
			   { { "%f[^>][^<]", "%f[<]" }, "normal" },
			   { { "\"", "\"", "\\" }, "string" },
			   { { "'", "'", "\\" }, "string" },
			   { { "0x[%da-fA-F]+" }, "number" },
			   { { "-?%d+[%d%.]*f?" }, "number" },
			   { { "-?%.?%d+f?" }, "number" },
			   { { "%f[^<]![%a_][%w_]*" }, "keyword2" },
			   { { "%f[^<][%a_][%w_]*" }, "function" },
			   { { "%f[^<]/[%a_][%w_]*" }, "function" },
			   { { "[%a_][%w_]*" }, "keyword" },
			   { { "[/<>=]" }, "operator" },
		   },
		   {},
		   "",
		   { "<%?xml" } } );

	// HTML
	add( { "HTML",
		   { "%.html?$", "%.php$", "%.php3$", "%.php4$", "%.php5$", "%.phtml", "%.handlebars" },
		   {
			   { { "<%s*[sS][cC][rR][iI][pP][tT]%s+[tT][yY][pP][eE]%s*=%s*['\"]%a+/"
				   "[jJ][aA][vV][aA][sS][cC][rR][iI][pP][tT]['\"]%s*>",
				   "<%s*/[sS][cC][rR][iI][pP][tT]>" },
				 "function",
				 "JavaScript" },
			   { { "<%s*[sS][cC][rR][iI][pP][tT]%s*>", "<%s*/%s*[sS][cC][rR][iI][pP][tT]>" },
				 "function",
				 "JavaScript" },
			   { { "<%s*[sS][tT][yY][lL][eE][^>]*>", "<%s*/%s*[sS][tT][yY][lL][eE]%s*>" },
				 "function",
				 "CSS" },
			   { { "<%?p?h?p?", "%?>" }, "function", "PHP" },
			   { { "<!%-%-", "%-%->" }, "comment" },
			   { { "%f[^>][^<]", "%f[<]" }, "normal" },
			   { { "\"", "\"", "\\" }, "string" },
			   { { "'", "'", "\\" }, "string" },
			   { { "0x[%da-fA-F]+" }, "number" },
			   { { "-?%d+[%d%.]*f?" }, "number" },
			   { { "-?%.?%d+f?" }, "number" },
			   { { "%f[^<]![%a_][%w_]*" }, "keyword2" },
			   { { "%f[^<][%a_][%w_]*" }, "function" },
			   { { "%f[^<]/[%a_][%w_]*" }, "function" },
			   { { "[%a_][%w_]*" }, "keyword" },
			   { { "[/<>=]" }, "operator" },
		   },
		   {},
		   "",
		   { "<html", "<![Dd][Oo][Cc][Tt][Yy][Pp][Ee]%s[Hh][Tt][Mm][Ll]>" } } );

	// CSS
	add( { "CSS",
		   { "%.css$" },
		   {
			   { { "\\." }, "normal" },
			   { { "//.-\n" }, "comment" },
			   { { "/%*", "%*/" }, "comment" },
			   { { "\"", "\"", "\\" }, "string" },
			   { { "'", "'", "\\" }, "string" },
			   { { "[%a][%w-]*%s*%f[:]" }, "keyword" },
			   { { "#%x+" }, "string" },
			   { { "-?%d+[%d%.]*p[xt]" }, "number" },
			   { { "-?%d+[%d%.]*deg" }, "number" },
			   { { "-?%d+[%d%.]*" }, "number" },
			   { { "[%a_][%w_]*" }, "symbol" },
			   { { "#[_-%a][%w_-]*" }, "keyword2" },
			   { { "@[%a][%w_-]*" }, "keyword2" },
			   { { "%.[_-%a][%w_-]*" }, "keyword2" },
			   { { "[{}:]" }, "operator" },
		   } } )
		.addSymbols( UIWidgetCreator::getWidgetNames(), "keyword2" );

	// Markdown
	add( { "Markdown",
		   { "%.md$", "%.markdown$" },
		   {
			   { { "\\." }, "normal" },
			   { { "```[Xx][Mm][Ll]", "```" }, "function", "XML" },
			   { { "```[Hh][Tt][Mm][Ll]", "```" }, "function", "html" },
			   { { "```[Cc]++", "```" }, "function", "C++" },
			   { { "```[Cc][Pp][Pp]", "```" }, "function", "C++" },
			   { { "```[Cc]%#", "```" }, "function", "C#" },
			   { { "```[Cc][Ss][Ss]", "```" }, "function", "CSS" },
			   { { "```[Cc]", "```" }, "function", "C" },
			   { { "```[Dd]", "```" }, "function", "D" },
			   { { "```[Ll]ua", "```" }, "function", "Lua" },
			   { { "```[Ja]va[Ss]cript", "```" }, "function", "JavaScript" },
			   { { "```[Tt]ype[Ss]cript", "```" }, "function", "TypeScript" },
			   { { "```[Pp]ython", "```" }, "function", "Python" },
			   { { "```[Bb]ash", "```" }, "function", "Bash" },
			   { { "```[Pp][Hh][Pp]", "```" }, "function", "PHP" },
			   { { "```[Ss][Qq][Ll]", "```" }, "function", "SQL" },
			   { { "```[Gg][Ll][Ss][Ll]", "```" }, "function", "GLSL" },
			   { { "```[Ii][Nn][Ii]", "```" }, "function", "Config File" },
			   { { "```[Mm]makefile", "```" }, "function", "Makefile" },
			   { { "```[Gg][Oo]", "```" }, "function", "Go" },
			   { { "```[Rr]ust", "```" }, "function", "Rust" },
			   { { "```[Gg][Dd][Ss]cript", "```" }, "function", "GSCript" },
			   { { "```[Jj]ava", "```" }, "function", "java" },
			   { { "```[Ss]wift", "```" }, "function", "Swift" },
			   { { "```[Dd]art", "```" }, "function", "Dart" },
			   { { "```[Oo]bjective[Cc]", "```" }, "function", "Objective-C" },
			   { { "```[Yy][Aa][Mm][Ll]", "```" }, "function", "YAML" },
			   { { "```[Kk]otlin", "```" }, "function", "Kotlin" },
			   { { "```[Ss]olidity", "```" }, "function", "Solidity" },
			   { { "```[Hh]askell", "```" }, "function", "Haskell" },
			   { { "<!%-%-", "%-%->" }, "comment" },
			   { { "```", "```" }, "string" },
			   { { "``", "``" }, "string" },
			   { { "`", "`" }, "string" },
			   { { "~~", "~~", "\\" }, "keyword2" },
			   { { "%-%-%-+" }, "comment" },
			   { { "%*%s+" }, "operator" },
			   { { "%*", "[%*\n]", "\\" }, "operator" },
			   { { "%s%_", "[%_\n]", "\\" }, "keyword2" },
			   { { "^%_", "[%_\n]", "\\" }, "keyword2" },
			   { { "#.-\n" }, "keyword" },
			   { { "!?%[.-%]%(https?://%S-%)" }, "link" },
			   { { "!?%[.-%]%(.-%)" }, "function" },
			   { { "https?://%S+" }, "link" },
		   } } );

	// C
	add( { "C",
		   { "%.c$", "%.h$" },
		   {
			   { { "//.-\n" }, "comment" },
			   { { "/%*", "%*/" }, "comment" },
			   { { "#", "[^\\]\n" }, "comment" },
			   { { "\"", "\"", "\\" }, "string" },
			   { { "'", "'", "\\" }, "string" },
			   { { "-?0x%x+" }, "number" },
			   { { "-?%d+[%d%.eE]*f?" }, "number" },
			   { { "-?%.?%d+f?" }, "number" },
			   { { "[%+%-=/%*%^%%<>!~|&]" }, "operator" },
			   { { "[%a_][%w_]*%f[(]" }, "function" },
			   { { "[%a_][%w_]*" }, "symbol" },
		   },
		   {
			   { "if", "keyword" },		 { "then", "keyword" },	   { "else", "keyword" },
			   { "elseif", "keyword" },	 { "do", "keyword" },	   { "while", "keyword" },
			   { "for", "keyword" },	 { "break", "keyword" },   { "continue", "keyword" },
			   { "return", "keyword" },	 { "goto", "keyword" },	   { "struct", "keyword" },
			   { "union", "keyword" },	 { "typedef", "keyword" }, { "enum", "keyword" },
			   { "extern", "keyword" },	 { "static", "keyword" },  { "volatile", "keyword" },
			   { "const", "keyword" },	 { "inline", "keyword" },  { "switch", "keyword" },
			   { "case", "keyword" },	 { "default", "keyword" }, { "auto", "keyword" },
			   { "const", "keyword" },	 { "void", "keyword" },	   { "int", "keyword2" },
			   { "short", "keyword2" },	 { "long", "keyword2" },   { "float", "keyword2" },
			   { "double", "keyword2" }, { "char", "keyword2" },   { "unsigned", "keyword2" },
			   { "bool", "keyword2" },	 { "true", "literal" },	   { "false", "literal" },
			   { "NULL", "literal" },
		   },
		   "//" } );

	// Lua
	add( { "Lua",
		   { "%.lua$" },
		   {
			   { { "\"", "\"", "\\" }, "string" },
			   { { "'", "'", "\\" }, "string" },
			   { { "%[%[", "%]%]" }, "string" },
			   { { "%-%-%[%[", "%]%]" }, "comment" },
			   { { "%-%-.-\n" }, "comment" },
			   { { "-?0x%x+" }, "number" },
			   { { "-?%d+[%d%.eE]*" }, "number" },
			   { { "-?%.?%d+" }, "number" },
			   { { "%.%.%.?" }, "operator" },
			   { { "[<>~=]=" }, "operator" },
			   { { "[%+%-=/%*%^%%#<>]" }, "operator" },
			   { { "[%a_][%w_]*%s*%f[(\"{]" }, "function" },
			   { { "[%a_][%w_]*" }, "symbol" },
			   { { "::[%a_][%w_]*::" }, "function" },
		   },
		   {
			   { "if", "keyword" },		  { "then", "keyword" },   { "else", "keyword" },
			   { "elseif", "keyword" },	  { "end", "keyword" },	   { "do", "keyword" },
			   { "function", "keyword" }, { "repeat", "keyword" }, { "until", "keyword" },
			   { "while", "keyword" },	  { "for", "keyword" },	   { "break", "keyword" },
			   { "return", "keyword" },	  { "local", "keyword" },  { "in", "keyword" },
			   { "not", "keyword" },	  { "and", "keyword" },	   { "or", "keyword" },
			   { "goto", "keyword" },	  { "self", "keyword2" },  { "true", "literal" },
			   { "false", "literal" },	  { "nil", "literal" },
		   },
		   "--",
		   { "^#!.*[ /]lua" } } );

	// JavaScript
	add( { "JavaScript",
		   { "%.js$", "%.json$", "%.cson$" },
		   {
			   { { "//.-\n" }, "comment" },
			   { { "/%*", "%*/" }, "comment" },
			   { { "\"", "\"", "\\" }, "string" },
			   { { "'", "'", "\\" }, "string" },
			   { { "`", "`", "\\" }, "string" },
			   { { "0x[%da-fA-F]+" }, "number" },
			   { { "-?%d+[%d%.eE]*" }, "number" },
			   { { "-?%.?%d+" }, "number" },
			   { { "[%+%-=/%*%^%%<>!~|&]" }, "operator" },
			   { { "[%a_][%w_]*%s*%f[(]" }, "function" },
			   { { "[%a_][%w_]*" }, "symbol" },
		   },
		   { { "arguments", "keyword2" }, { "async", "keyword" },	   { "await", "keyword" },
			 { "break", "keyword" },	  { "case", "keyword" },	   { "catch", "keyword" },
			 { "class", "keyword" },	  { "const", "keyword" },	   { "continue", "keyword" },
			 { "debugger", "keyword" },	  { "default", "keyword" },	   { "delete", "keyword" },
			 { "do", "keyword" },		  { "else", "keyword" },	   { "export", "keyword" },
			 { "extends", "keyword" },	  { "false", "literal" },	   { "finally", "keyword" },
			 { "for", "keyword" },		  { "function", "keyword" },   { "get", "keyword" },
			 { "if", "keyword" },		  { "import", "keyword" },	   { "in", "keyword" },
			 { "Infinity", "keyword2" },  { "instanceof", "keyword" }, { "let", "keyword" },
			 { "NaN", "keyword2" },		  { "new", "keyword" },		   { "null", "literal" },
			 { "return", "keyword" },	  { "set", "keyword" },		   { "super", "keyword" },
			 { "static", "keyword" },	  { "switch", "keyword" },	   { "this", "keyword2" },
			 { "throw", "keyword" },	  { "true", "literal" },	   { "try", "keyword" },
			 { "typeof", "keyword" },	  { "undefined", "literal" },  { "var", "keyword" },
			 { "void", "keyword" },		  { "while", "keyword" },	   { "with", "keyword" },
			 { "yield", "keyword" },	  { "implements", "keyword" }, { "Array", "keyword2" },
			 { "any", "keyword" },		  { "from", "keyword" },	   { "public", "keyword" },
			 { "private", "keyword" },	  { "declare", "keyword" },	   { "namespace", "keyword" },
			 { "protected", "keyword" },  { "enum", "keyword" } },
		   "//" } );

	// TypeScript
	add(
		{ "TypeScript",
		  { "%.ts$", "%.tsx$", "%.d.ts$" },
		  {
			  { { "//.-\n" }, "comment" },
			  { { "/%*", "%*/" }, "comment" },
			  { { "\"", "\"", "\\" }, "string" },
			  { { "'", "'", "\\" }, "string" },
			  { { "`", "`", "\\" }, "string" },
			  { { "0x[%da-fA-F]+" }, "number" },
			  { { "-?%d+[%d%.eE]*" }, "number" },
			  { { "-?%.?%d+" }, "number" },
			  { { "[%+%-=/%*%^%%<>!~|&]" }, "operator" },
			  { { "[%a_][%w_]*%s*%f[(]" }, "function" },
			  { { "[%a_][%w_]*" }, "symbol" },
		  },
		  { { "any", "keyword2" },		 { "arguments", "keyword2" }, { "as", "keyword2" },
			{ "async", "keyword" },		 { "await", "keyword" },	  { "boolean", "keyword2" },
			{ "break", "keyword" },		 { "case", "keyword" },		  { "catch", "keyword" },
			{ "class", "keyword" },		 { "const", "keyword" },	  { "constructor", "keyword2" },
			{ "continue", "keyword" },	 { "debugger", "keyword" },	  { "declare", "keyword2" },
			{ "default", "keyword" },	 { "delete", "keyword" },	  { "do", "keyword" },
			{ "else", "keyword" },		 { "enum", "keyword2" },	  { "export", "keyword" },
			{ "extends", "keyword" },	 { "false", "literal" },	  { "finally", "keyword" },
			{ "for", "keyword" },		 { "from", "keyword" },		  { "function", "keyword" },
			{ "get", "keyword" },		 { "if", "keyword" },		  { "implements", "keyword2" },
			{ "import", "keyword" },	 { "in", "keyword" },		  { "Infinity", "keyword2" },
			{ "instanceof", "keyword" }, { "interface", "keyword2" }, { "let", "keyword" },
			{ "module", "keyword2" },	 { "new", "keyword" },		  { "null", "literal" },
			{ "number", "keyword2" },	 { "of", "keyword2" },		  { "package", "keyword2" },
			{ "private", "keyword2" },	 { "protected", "keyword2" }, { "public", "keyword2" },
			{ "require", "keyword2" },	 { "return", "keyword" },	  { "set", "keyword" },
			{ "static", "keyword" },	 { "string", "keyword2" },	  { "super", "keyword" },
			{ "switch", "keyword" },	 { "symbol", "keyword2" },	  { "this", "keyword2" },
			{ "throw", "keyword" },		 { "true", "literal" },		  { "try", "keyword" },
			{ "type", "keyword2" },		 { "typeof", "keyword" },	  { "undefined", "literal" },
			{ "var", "keyword" },		 { "void", "keyword" },		  { "while", "keyword" },
			{ "with", "keyword" },		 { "yield", "keyword" } },
		  "//" } );

	// Python
	add( { "Python",
		   { "%.py$", "%.pyw$" },
		   {
			   { { "#", "\n" }, "comment" },
			   { { "[ruU]?\"", "\"", "\\" }, "string" },
			   { { "[ruU]?'", "'", "\\" }, "string" },
			   { { "\"\"\"", "\"\"\"" }, "string" },
			   { { "0x[%da-fA-F]+" }, "number" },
			   { { "-?%d+[%d%.eE]*" }, "number" },
			   { { "-?%.?%d+" }, "number" },
			   { { "[%+%-=/%*%^%%<>!~|&]" }, "operator" },
			   { { "[%a_][%w_]*%f[(]" }, "function" },
			   { { "[%a_][%w_]*" }, "symbol" },
		   },
		   {
			   { "class", "keyword" },	{ "finally", "keyword" },  { "is", "keyword" },
			   { "return", "keyword" }, { "continue", "keyword" }, { "for", "keyword" },
			   { "lambda", "keyword" }, { "try", "keyword" },	   { "def", "keyword" },
			   { "from", "keyword" },	{ "nonlocal", "keyword" }, { "while", "keyword" },
			   { "and", "keyword" },	{ "global", "keyword" },   { "not", "keyword" },
			   { "with", "keyword" },	{ "as", "keyword" },	   { "elif", "keyword" },
			   { "if", "keyword" },		{ "or", "keyword" },	   { "else", "keyword" },
			   { "import", "keyword" }, { "pass", "keyword" },	   { "break", "keyword" },
			   { "except", "keyword" }, { "in", "keyword" },	   { "del", "keyword" },
			   { "raise", "keyword" },	{ "yield", "keyword" },	   { "assert", "keyword" },
			   { "self", "keyword2" },	{ "None", "literal" },	   { "True", "literal" },
			   { "False", "literal" },
		   },
		   "#",
		   { "^#!.*[ /]python", "^#!.*[ /]python3" } } );

	// sh - bash
	add( { "Bash",
		   { "%.sh$", "%.bash$", "%.bashrc$", "%.bash_profile$" },
		   {
			   { { "#.*\n" }, "comment" },
			   { { "[[\\.]]" }, "normal" },
			   { { "\"", "\"", "\\" }, "string" },
			   { { "'", "'", "\\" }, "string" },
			   { { "`", "`", "\\" }, "string" },
			   { { "%f[%w_][%d%.]+%f[^%w_]" }, "number" },
			   { { "[!<>|&%[%]=*]" }, "operator" },
			   { { "%f[%S]%-[%w%-_]+" }, "function" },
			   { { "${.*}" }, "keyword2" },
			   { { "$[%a_@*][%w_]*" }, "keyword2" },
			   { { "[%a_][%w_]*" }, "symbol" },
		   },
		   {
			   { "case", "keyword" },  { "do", "keyword" },	  { "done", "keyword" },
			   { "elif", "keyword" },  { "else", "keyword" }, { "esac", "keyword" },
			   { "fi", "keyword" },	   { "for", "keyword" },  { "function", "keyword" },
			   { "if", "keyword" },	   { "in", "keyword" },	  { "select", "keyword" },
			   { "then", "keyword" },  { "time", "keyword" }, { "until", "keyword" },
			   { "while", "keyword" }, { "echo", "keyword" }, { "true", "literal" },
			   { "false", "literal" },
		   },
		   "#",
		   { "^#!.*[ /]bash", "^#!.*[ /]sh" } } );

	// C++
	add( { "C++",
		   { "%.cpp$", "%.cc$", "%.C$", "%.cxx$", "%.c++$", "%.hh$", "%.H$", "%.h$", "%.inl$",
			 "%.hxx$", "%.hpp$", "%.h++$" },
		   {
			   { { "R%\"xml%(", "%)xml%\"" }, "function", "XML" },
			   { { "R%\"css%(", "%)css%\"" }, "function", "CSS" },
			   { { "R%\"html%(", "%)html%\"" }, "function", "HTML" },
			   { { "R\"[%a-\"]+%(", "%)[%a-\"]+%\"" }, "string" },
			   { { "//.-\n" }, "comment" },
			   { { "/%*", "%*/" }, "comment" },
			   { { "#", "[^\\]\n" }, "keyword2" },
			   { { "\"", "\"", "\\" }, "string" },
			   { { "'", "'", "\\" }, "string" },
			   { { "-?0x%x+" }, "number" },
			   { { "-?%d+[%d%.eE]*f?" }, "number" },
			   { { "-?%.?%d+f?" }, "number" },
			   { { "[%+%-=/%*%^%%<>!~|&]" }, "operator" },
			   { { "[%a_][%w_]*%s*%f[(]" }, "function" },
			   { { "std%:%:[%w_]*" }, "keyword2" },
			   { { "[%a_][%w_]*" }, "symbol" },
		   },
		   {
			   { "alignof", "keyword" },
			   { "alignas", "keyword" },
			   { "and", "keyword" },
			   { "and_eq", "keyword" },
			   { "not", "keyword" },
			   { "not_eq", "keyword" },
			   { "or", "keyword" },
			   { "or_eq", "keyword" },
			   { "xor", "keyword" },
			   { "xor_eq", "keyword" },
			   { "private", "keyword" },
			   { "protected", "keyword" },
			   { "public", "keyword" },
			   { "register", "keyword" },
			   { "nullptr", "keyword" },
			   { "operator", "keyword" },
			   { "asm", "keyword" },
			   { "bitand", "keyword" },
			   { "bitor", "keyword" },
			   { "catch", "keyword" },
			   { "throw", "keyword" },
			   { "try", "keyword" },
			   { "class", "keyword" },
			   { "compl", "keyword" },
			   { "explicit", "keyword" },
			   { "export", "keyword" },
			   { "concept", "keyword" },
			   { "consteval", "keyword" },
			   { "constexpr", "keyword" },
			   { "constinit", "keyword" },
			   { "const_cast", "keyword" },
			   { "dynamic_cast", "keyword" },
			   { "reinterpret_cast", "keyword" },
			   { "static_cast", "keyword" },
			   { "static_assert", "keyword" },
			   { "template", "keyword" },
			   { "this", "keyword" },
			   { "thread_local", "keyword" },
			   { "requires", "keyword" },
			   { "co_wait", "keyword" },
			   { "co_return", "keyword" },
			   { "co_yield", "keyword" },
			   { "decltype", "keyword" },
			   { "delete", "keyword" },
			   { "export", "keyword" },
			   { "friend", "keyword" },
			   { "typeid", "keyword" },
			   { "typename", "keyword" },
			   { "mutable", "keyword" },
			   { "virtual", "keyword" },
			   { "using", "keyword" },
			   { "namespace", "keyword" },
			   { "new", "keyword" },
			   { "noexcept", "keyword" },
			   { "if", "keyword" },
			   { "then", "keyword" },
			   { "else", "keyword" },
			   { "elseif", "keyword" },
			   { "do", "keyword" },
			   { "while", "keyword" },
			   { "for", "keyword" },
			   { "break", "keyword" },
			   { "continue", "keyword" },
			   { "return", "keyword" },
			   { "goto", "keyword" },
			   { "struct", "keyword" },
			   { "union", "keyword" },
			   { "typedef", "keyword" },
			   { "enum", "keyword" },
			   { "extern", "keyword" },
			   { "static", "keyword" },
			   { "volatile", "keyword" },
			   { "const", "keyword" },
			   { "inline", "keyword" },
			   { "switch", "keyword" },
			   { "case", "keyword" },
			   { "default", "keyword" },
			   { "auto", "keyword" },
			   { "const", "keyword" },
			   { "void", "keyword" },
			   { "int", "keyword2" },
			   { "short", "keyword2" },
			   { "long", "keyword2" },
			   { "float", "keyword2" },
			   { "double", "keyword2" },
			   { "char", "keyword2" },
			   { "unsigned", "keyword2" },
			   { "bool", "keyword2" },
			   { "true", "keyword2" },
			   { "false", "keyword2" },
			   { "wchar_t", "keyword2" },
			   { "char8_t", "keyword2" },
			   { "char16_t", "keyword2" },
			   { "char32_t", "keyword2" },
			   { "size_t", "keyword2" },
			   { "int16_t", "keyword2" },
			   { "int32_t", "keyword2" },
			   { "int64_t", "keyword2" },
			   { "uint16_t", "keyword2" },
			   { "uint32_t", "keyword2" },
			   { "uint64_t", "keyword2" },
			   { "String", "keyword2" },
			   { "Int8", "keyword2" },
			   { "Uint8", "keyword2" },
			   { "Int16", "keyword2" },
			   { "Uint16", "keyword2" },
			   { "Int32", "keyword2" },
			   { "Uint32", "keyword2" },
			   { "Int64", "keyword2" },
			   { "Uint64", "keyword2" },
			   { "Float", "keyword2" },
			   { "Color", "keyword2" },
			   { "Vector2f", "keyword2" },
			   { "Vector2i", "keyword2" },
			   { "Recti", "keyword2" },
			   { "Rectf", "keyword2" },
			   { "NULL", "literal" },
		   },
		   "//" } );

	// PHP
	add( { "PHP",
		   {},
		   {
			   { { "<%?p?h?p?" }, "function" },
			   { { "%?>", "<%?p?h?p?" }, "function", "HTML" },
			   { { "//.-\n" }, "comment" },
			   { { "/%*", "%*/" }, "comment" },
			   { { "#.-\n" }, "comment" },
			   { { "\"", "\"", "\\" }, "string" },
			   { { "'", "'", "\\" }, "string" },
			   { { "%\\x[%da-fA-F]+" }, "number" },
			   { { "-?%d+[%d%.eE]*" }, "number" },
			   { { "-?%.?%d+" }, "number" },
			   { { "[%.%+%-=/%*%^%%<>!~|&]" }, "operator" },
			   { { "[%a_][%w_]*%f[(]" }, "function" },
			   { { "[%a_][%w_]*" }, "symbol" },
			   { { "%$[%a][%w_]*" }, "keyword2" },
		   },
		   { { "return", "keyword" },	   { "if", "keyword" },
			 { "else", "keyword" },		   { "elseif", "keyword" },
			 { "endif", "keyword" },	   { "declare", "keyword" },
			 { "enddeclare", "keyword" },  { "switch", "keyword" },
			 { "endswitch", "keyword" },   { "as", "keyword" },
			 { "do", "keyword" },		   { "for", "keyword" },
			 { "endfor", "keyword" },	   { "foreach", "keyword" },
			 { "endforeach", "keyword" },  { "while", "keyword" },
			 { "endwhile", "keyword" },	   { "switch", "keyword" },
			 { "case", "keyword" },		   { "continue", "keyword" },
			 { "default", "keyword" },	   { "break", "keyword" },
			 { "exit", "keyword" },		   { "goto", "keyword" },

			 { "catch", "keyword" },	   { "throw", "keyword" },
			 { "try", "keyword" },		   { "finally", "keyword" },

			 { "class", "keyword" },	   { "trait", "keyword" },
			 { "interface", "keyword" },   { "public", "keyword" },
			 { "static", "keyword" },	   { "protected", "keyword" },
			 { "private", "keyword" },	   { "abstract", "keyword" },
			 { "final", "keyword" },

			 { "function", "keyword2" },   { "global", "keyword2" },
			 { "var", "keyword2" },		   { "const", "keyword2" },
			 { "bool", "keyword2" },	   { "boolean", "keyword2" },
			 { "int", "keyword2" },		   { "integer", "keyword2" },
			 { "real", "keyword2" },	   { "double", "keyword2" },
			 { "float", "keyword2" },	   { "string", "keyword2" },
			 { "array", "keyword2" },	   { "object", "keyword2" },
			 { "callable", "keyword2" },   { "iterable", "keyword2" },

			 { "namespace", "keyword2" },  { "extends", "keyword2" },
			 { "implements", "keyword2" }, { "instanceof", "keyword2" },
			 { "require", "keyword2" },	   { "require_once", "keyword2" },
			 { "include", "keyword2" },	   { "include_once", "keyword2" },
			 { "use", "keyword2" },		   { "new", "keyword2" },
			 { "clone", "keyword2" },

			 { "true", "literal" },		   { "false", "literal" },
			 { "NULL", "literal" },		   { "parent", "literal" },
			 { "self", "literal" },		   { "echo", "function" } },
		   "//",
		   { "^#!.*[ /]php" } } );

	// Add SQL
	std::vector<std::string> keywords = {
		"CREATE",	  "SELECT",		"INSERT",	 "INTO",	  "UPDATE",		  "DELETE",
		"TABLE",	  "DROP",		"VALUES",	 "NOT",		  "NULL",		  "PRIMARY",
		"KEY",		  "REFERENCES", "DEFAULT",	 "UNIQUE",	  "CONSTRAINT",	  "CHECK",
		"ON",		  "EXCLUDE",	"WITH",		 "USING",	  "WHERE",		  "GROUP",
		"BY",		  "HAVING",		"DISTINCT",	 "LIMIT",	  "OFFSET",		  "ONLY",
		"CROSS",	  "JOIN",		"INNER",	 "LEFT",	  "RIGHT",		  "FULL",
		"OUTER",	  "NATURAL",	"AND",		 "OR",		  "AS",			  "ORDER",
		"ORDINALITY", "UNNEST",		"FROM",		 "VIEW",	  "RETURNS",	  "SETOF",
		"LANGUAGE",	  "SQL",		"LIKE",		 "LATERAL",	  "INTERVAL",	  "PARTITION",
		"UNION",	  "INTERSECT",	"EXCEPT",	 "ALL",		  "ASC",		  "DESC",
		"NULLS",	  "FIRST",		"LAST",		 "IN",		  "RECURSIVE",	  "ARRAY",
		"RETURNING",  "SET",		"ALSO",		 "INSTEAD",	  "ALTER",		  "SEQUENCE",
		"OWNED",	  "AT",			"ZONE",		 "WITHOUT",	  "TO",			  "TIMEZONE",
		"TYPE",		  "ENUM",		"DOCUMENT",	 "XMLPARSE",  "XMLSERIALIZE", "CONTENT",
		"OPTION",	  "INDEX",		"ANY",		 "EXTENSION", "ISNULL",		  "NOTNULL",
		"UNKNOWN",	  "CASE",		"THEN",		 "WHEN",	  "ELSE",		  "END",
		"ROWS",		  "BETWEEN",	"UNBOUNDED", "PRECEDING", "UNBOUNDED",	  "FOLLOWING",
		"EXISTS",	  "SOME",		"COLLATION", "FOR",		  "TRIGGER",	  "BEFORE",
		"EACH",		  "ROW",		"EXECUTE",	 "PROCEDURE", "FUNCTION",	  "DECLARE",
		"BEGIN",	  "LOOP",		"RAISE",	 "NOTICE",	  "LOOP",		  "EVENT",
		"OPERATOR",	  "DOMAIN",		"VARIADIC",	 "FOREIGN" };

	std::vector<std::string> types = {
		"BIGINT",	 "INT8",	 "BIGSERIAL",	  "SERIAL8",	 "BIT",		  "VARBIT",
		"BOOLEAN",	 "BOOL",	 "BOX",			  "BYTEA",		 "CHARACTER", "CHAR",
		"VARCHAR",	 "CIDR",	 "CIRCLE",		  "DATE",		 "DOUBLE",	  "PRECISION",
		"FLOAT8",	 "INET",	 "INTEGER",		  "INT",		 "INT4",	  "INTERVAL",
		"JSON",		 "JSONB",	 "LINE",		  "LSEG",		 "MACADDR",	  "MONEY",
		"NUMERIC",	 "DECIMAL",	 "PATH",		  "POINT",		 "POLYGON",	  "REAL",
		"FLOAT4",	 "INT2",	 "SMALLINT",	  "SMALLSERIAL", "SERIAL2",	  "SERIAL",
		"SERIAL4",	 "TEXT",	 "TIME",		  "TIMEZ",		 "TIMESTAMP", "TIMESTAMPZ",
		"TSQUERY",	 "TSVECTOR", "TXID_SNAPSHOT", "UUID",		 "XML",		  "INT4RANGE",
		"INT8RANGE", "NUMRANGE", "TSRANGE",		  "TSTZRANGE",	 "DATERANGE", "PG_LSN" };

	std::vector<std::string> literals = { "FALSE",		   "TRUE",		   "CURRENT_TIMESTAMP",
										  "CURRENT_TIME",  "CURRENT_DATE", "LOCALTIME",
										  "LOCALTIMESTAMP" };

	std::unordered_map<std::string, std::string> symbols;
	for ( auto& keyword : keywords ) {
		symbols[String::toLower( keyword )] = "keyword";
		symbols[keyword] = "keyword";
	}

	for ( auto& type : types ) {
		symbols[String::toLower( type )] = "keyword2";
		symbols[type] = "keyword2";
	}

	for ( auto& literal : literals ) {
		symbols[String::toLower( literal )] = "literal";
		symbols[literal] = "literal";
	}

	add( { "SQL",
		   { "%.sql$", "%.psql$" },
		   {
			   { { "%-%-.-\n" }, "comment" },
			   { { "/%*", "%*/" }, "comment" },
			   { { "'", "'", "\\" }, "string" },
			   { { "-?%d+[%d%.eE]*f?" }, "number" },
			   { { "-?%.?%d+f?" }, "number" },
			   { { "[%+%-=/%*%%<>!~|&@%?$#]" }, "operator" },
			   { { "[%a_][%w_]*%f[(]" }, "function" },
			   { { "[%a_][%w_]*" }, "symbol" },
		   },
		   symbols,
		   "--" } );

	// GLSL
	add( { "GLSL",
		   { "%.glsl$", "%.frag$", "%.vert$" },
		   {
			   { { "//.-\n" }, "comment" },
			   { { "/%*", "%*/" }, "comment" },
			   { { "#", "[^\\]\n" }, "comment" },
			   { { "\"", "\"", "\\" }, "string" },
			   { { "'", "'", "\\" }, "string" },
			   { { "-?0x%x+" }, "number" },
			   { { "-?%d+[%d%.eE]*f?" }, "number" },
			   { { "-?%.?%d+f?" }, "number" },
			   { { "[%+%-=/%*%^%%<>!~|&]" }, "operator" },
			   { { "ivec[2-4]" }, "keyword2" },
			   { { "bvec[2-4]" }, "keyword2" },
			   { { "uvec[2-4]" }, "keyword2" },
			   { { "vec[2-4]" }, "keyword2" },
			   { { "dmat[2-4]x[2-4]" }, "keyword2" },
			   { { "dmat[2-4]" }, "keyword2" },
			   { { "mat[2-4]x[2-4]" }, "keyword2" },
			   { { "mat[2-4]" }, "keyword2" },
			   { { "[%a_][%w_]*%f[(]" }, "function" },
			   { { "[%a_][%w_]*" }, "symbol" },
		   },
		   {
			   { "if", "keyword" },
			   { "else", "keyword" },
			   { "do", "keyword" },
			   { "while", "keyword" },
			   { "for", "keyword" },
			   { "break", "keyword" },
			   { "continue", "keyword" },
			   { "return", "keyword" },
			   { "const", "keyword" },
			   { "switch", "keyword" },
			   { "case", "keyword" },
			   { "default", "keyword" },
			   { "const", "keyword" },
			   { "void", "keyword" },
			   { "bool", "keyword2" },
			   { "int", "keyword2" },
			   { "uint", "keyword2" },
			   { "float", "keyword2" },
			   { "double", "keyword2" },
			   { "true", "literal" },
			   { "false", "literal" },
			   { "NULL", "literal" },
			   { "attribute", "keyword" },
			   { "varying", "keyword" },
			   { "uniform", "keyword" },
			   { "buffer", "keyword" },
			   { "shared", "keyword" },
			   { "layout", "keyword" },
			   { "centroid", "keyword" },
			   { "flat", "keyword" },
			   { "smooth", "keyword" },
			   { "noperspective", "keyword" },
			   { "patch", "keyword" },
			   { "sample", "keyword" },
			   { "in", "keyword" },
			   { "out", "keyword" },
			   { "inout", "keyword" },
			   { "invariant", "keyword" },
			   { "precise", "keyword" },
			   { "lowp", "keyword" },
			   { "mediump", "keyword" },
			   { "highp", "keyword" },
			   { "precision", "keyword" },
			   { "struct", "keyword" },
			   { "subroutine", "keyword" },
			   { "coherent", "keyword" },
			   { "volatile", "keyword" },
			   { "readonly", "keyword" },
			   { "writeonly", "keyword" },
			   { "sampler1D", "keyword2" },
			   { "sampler2D", "keyword2" },
			   { "sampler3D", "keyword2" },
			   { "samplerCube", "keyword2" },
			   { "sampler1DShadow", "keyword2" },
			   { "sampler2DShadow", "keyword2" },
			   { "samplerCubeShadow", "keyword2" },
			   { "sampler1DArray", "keyword2" },
			   { "sampler2DArray", "keyword2" },
			   { "samplerCubeArray", "keyword2" },
			   { "sampler1DArrayShadow", "keyword2" },
			   { "sampler2DArrayShadow", "keyword2" },
			   { "samplerCubeArrayShadow", "keyword2" },
			   { "isampler1D", "keyword2" },
			   { "isampler2D", "keyword2" },
			   { "isampler3D", "keyword2" },
			   { "isamplerCube", "keyword2" },
			   { "sampler2DMS", "keyword2" },
			   { "isampler2DMS", "keyword2" },
			   { "usampler2DMS", "keyword2" },
			   { "sampler2DMSArray", "keyword2" },
			   { "isampler2DMSArray", "keyword2" },
			   { "usampler2DMSArray", "keyword2" },
			   { "isampler1DArray", "keyword2" },
			   { "isampler2DArray", "keyword2" },
			   { "usampler1D", "keyword2" },
			   { "usampler2D", "keyword2" },
			   { "usampler3D", "keyword2" },
			   { "usamplerCube", "keyword2" },
			   { "usampler1DArray", "keyword2" },
			   { "usampler2DArray", "keyword2" },
			   { "sampler2DRect", "keyword2" },
			   { "sampler2DRectShadow", "keyword2" },
			   { "isampler2DRect", "keyword2" },
			   { "usampler2DRect", "keyword2" },
			   { "samplerBuffer", "keyword2" },
			   { "isamplerBuffer", "keyword2" },
			   { "usamplerBuffer", "keyword2" },
			   { "image1D", "keyword2" },
			   { "iimage1D", "keyword2" },
			   { "uimage1D", "keyword2" },
			   { "image1DArray", "keyword2" },
			   { "iimage1DArray", "keyword2" },
			   { "uimage1DArray", "keyword2" },
			   { "image2D", "keyword2" },
			   { "iimage2D", "keyword2" },
			   { "uimage2D", "keyword2" },
			   { "image2DArray", "keyword2" },
			   { "iimage2DArray", "keyword2" },
			   { "uimage2DArray", "keyword2" },
			   { "image2DRect", "keyword2" },
			   { "iimage2DRect", "keyword2" },
			   { "uimage2DRect", "keyword2" },
			   { "image2DMS", "keyword2" },
			   { "iimage2DMS", "keyword2" },
			   { "uimage2DMS", "keyword2" },
			   { "image2DMSArray", "keyword2" },
			   { "iimage2DMSArray", "keyword2" },
			   { "uimage2DMSArray", "keyword2" },
			   { "image3D", "keyword2" },
			   { "iimage3D", "keyword2" },
			   { "uimage3D", "keyword2" },
			   { "imageCube", "keyword2" },
			   { "iimageCube", "keyword2" },
			   { "uimageCube", "keyword2" },
			   { "imageCubeArray", "keyword2" },
			   { "iimageCubeArray", "keyword2" },
			   { "uimageCubeArray", "keyword2" },
			   { "imageBuffer", "keyword2" },
			   { "iimageBuffer", "keyword2" },
			   { "uimageBuffer", "keyword2" },
			   { "atomic_uint", "keyword2" },
			   { "radians", "keyword" },
			   { "degrees", "keyword" },
			   { "sin", "keyword" },
			   { "cos", "keyword" },
			   { "tan", "keyword" },
			   { "asin", "keyword" },
			   { "acos", "keyword" },
			   { "atan", "keyword" },
			   { "sinh", "keyword" },
			   { "cosh", "keyword" },
			   { "tanh", "keyword" },
			   { "asinh", "keyword" },
			   { "acosh", "keyword" },
			   { "pow", "keyword" },
			   { "exp", "keyword" },
			   { "exp2", "keyword" },
			   { "log2", "keyword" },
			   { "sqrt", "keyword" },
			   { "inversesqrt", "keyword" },
			   { "abs", "keyword" },
			   { "sign", "keyword" },
			   { "floor", "keyword" },
			   { "trunc", "keyword" },
			   { "round", "keyword" },
			   { "roundEven", "keyword" },
			   { "ceil", "keyword" },
			   { "fract", "keyword" },
			   { "mod", "keyword" },
			   { "modf", "keyword" },
			   { "min", "keyword" },
			   { "max", "keyword" },
			   { "clamp", "keyword" },
			   { "mix", "keyword" },
			   { "step", "keyword" },
			   { "smoothstep", "keyword" },
			   { "isnan", "keyword" },
			   { "isinf", "keyword" },
			   { "floatBitsToInt", "keyword" },
			   { "floatBitsToUint", "keyword" },
			   { "intBitsToFloat", "keyword" },
			   { "uintBitsToFloat", "keyword" },
			   { "fma", "keyword" },
			   { "frexp", "keyword" },
			   { "ldexp", "keyword" },
			   { "packUnorm2x16", "keyword" },
			   { "packSnorm2x16", "keyword" },
			   { "packUnorm4x8", "keyword" },
			   { "packSnorm4x8", "keyword" },
			   { "unpackUnorm2x16", "keyword" },
			   { "unpackSnorm2x16", "keyword" },
			   { "unpackUnorm4x8", "keyword" },
			   { "unpackSnorm4x8", "keyword" },
			   { "packHalf2x16", "keyword" },
			   { "unpackHalf2x16", "keyword" },
			   { "packDouble2x32", "keyword" },
			   { "unpackDouble2x32", "keyword" },
			   { "length", "keyword" },
			   { "distance", "keyword" },
			   { "dot", "keyword" },
			   { "cross", "keyword" },
			   { "normalize", "keyword" },
			   { "ftransform", "keyword" },
			   { "faceforward", "keyword" },
			   { "reflect", "keyword" },
			   { "refract", "keyword" },
			   { "matrixCompMult", "keyword" },
			   { "outerProduct", "keyword" },
			   { "transpose", "keyword" },
			   { "determinant", "keyword" },
			   { "inverse", "keyword" },
			   { "lessThan", "keyword" },
			   { "lessThanEqual", "keyword" },
			   { "greaterThan", "keyword" },
			   { "greaterThanEqual", "keyword" },
			   { "equal", "keyword" },
			   { "notEqual", "keyword" },
			   { "any", "keyword" },
			   { "all", "keyword" },
			   { "not", "keyword" },
			   { "uaddCarry", "keyword" },
			   { "usubBorrow", "keyword" },
			   { "umulExtended", "keyword" },
			   { "imulExtended", "keyword" },
			   { "bitfieldExtract", "keyword" },
			   { "bitfieldInsert", "keyword" },
			   { "bitfieldReverse", "keyword" },
			   { "bitCount", "keyword" },
			   { "findLSB", "keyword" },
			   { "findMSB", "keyword" },
			   { "textureSize", "keyword" },
			   { "textureQueryLod", "keyword" },
			   { "textureQueryLevels", "keyword" },
			   { "textureSamples", "keyword" },
			   { "texture", "keyword" },
			   { "textureProj", "keyword" },
			   { "textureLod", "keyword" },
			   { "textureOffset", "keyword" },
			   { "texelFetch", "keyword" },
			   { "texelFetchOffset", "keyword" },
			   { "textureProjOffset", "keyword" },
			   { "textureLodOffset", "keyword" },
			   { "textureProjLod", "keyword" },
			   { "textureProjLodOffset", "keyword" },
			   { "textureGrad", "keyword" },
			   { "textureGradOffset", "keyword" },
			   { "textureProjGrad", "keyword" },
			   { "textureProjGradOffset", "keyword" },
			   { "textureGather", "keyword" },
			   { "textureGatherOffset", "keyword" },
			   { "textureGatherOffsets", "keyword" },
			   { "atomicCounterIncrement", "keyword" },
			   { "atomicCounterDecrement", "keyword" },
			   { "atomicCounter", "keyword" },
			   { "atomicCounterAdd", "keyword" },
			   { "atomicCounterSubtract", "keyword" },
			   { "atomicCounterMin", "keyword" },
			   { "atomicCounterMax", "keyword" },
			   { "atomicCounterAnd", "keyword" },
			   { "atomicCounterOr", "keyword" },
			   { "atomicCounterXor", "keyword" },
			   { "atomicCounterExchange", "keyword" },
			   { "atomicCounterCompSwap", "keyword" },
			   { "atomicAdd", "keyword" },
			   { "atomicMin", "keyword" },
			   { "atomicMax", "keyword" },
			   { "atomicAnd", "keyword" },
			   { "atomicOr", "keyword" },
			   { "atomicXor", "keyword" },
			   { "atomicExchange", "keyword" },
			   { "atomicCompSwap", "keyword" },
			   { "imageSize", "keyword" },
			   { "imageSamples", "keyword" },
			   { "imageLoad", "keyword" },
			   { "imageStore", "keyword" },
			   { "imageAtomicAdd", "keyword" },
			   { "imageAtomicMin", "keyword" },
			   { "imageAtomicMax", "keyword" },
			   { "imageAtomicAnd", "keyword" },
			   { "imageAtomicOr", "keyword" },
			   { "imageAtomicXor", "keyword" },
			   { "imageAtomicExchange", "keyword" },
			   { "imageAtomicCompSwap", "keyword" },
			   { "EmitStreamVertex", "keyword" },
			   { "EndStreamPrimitive", "keyword" },
			   { "EmitVertex", "keyword" },
			   { "EndPrimitive", "keyword" },
			   { "dFdx", "keyword" },
			   { "dFdy", "keyword" },
			   { "dFdxFine", "keyword" },
			   { "dFdyFine", "keyword" },
			   { "dFdxCoarse", "keyword" },
			   { "dFdyCoarse", "keyword" },
			   { "fwidth", "keyword" },
			   { "fwidthFine", "keyword" },
			   { "fwidthCoarse", "keyword" },
			   { "interpolateAtCentroid", "keyword" },
			   { "interpolateAtSample", "keyword" },
			   { "interpolateAtOffset", "keyword" },
			   { "barrier", "keyword" },
			   { "memoryBarrier", "keyword" },
			   { "memoryBarrierAtomicCounter", "keyword" },
			   { "memoryBarrierBuffer", "keyword" },
			   { "memoryBarrierShared", "keyword" },
			   { "memoryBarrierImage", "keyword" },
			   { "groupMemoryBarrier", "keyword" },
			   { "subpassLoad", "keyword" },
			   { "anyInvocation", "keyword" },
			   { "allInvocations", "keyword" },
			   { "allInvocationsEqual", "keyword" },
			   { "texture1D", "keyword" },
			   { "texture1DArray", "keyword" },
			   { "itexture1D", "keyword" },
			   { "itexture1DArray", "keyword" },
			   { "utexture1D", "keyword" },
			   { "utexture1DArray", "keyword" },
			   { "texture2D", "keyword" },
			   { "texture2DArray", "keyword" },
			   { "itexture2D", "keyword" },
			   { "itexture2DArray", "keyword" },
			   { "utexture2D", "keyword" },
			   { "utexture2DArray", "keyword" },
			   { "texture2DRect", "keyword" },
			   { "itexture2DRect", "keyword" },
			   { "utexture2DRect", "keyword" },
			   { "texture2DMS", "keyword" },
			   { "itexture2DMS", "keyword" },
			   { "utexture2DMS", "keyword" },
			   { "texture2DMSArray", "keyword" },
			   { "itexture2DMSArray", "keyword" },
			   { "utexture2DMSArray", "keyword" },
			   { "texture3D", "keyword" },
			   { "itexture3D", "keyword" },
			   { "utexture3D", "keyword" },
			   { "textureCube", "keyword" },
			   { "itextureCube", "keyword" },
			   { "utextureCube", "keyword" },
			   { "textureCubeArray", "keyword" },
			   { "itextureCubeArray", "keyword" },
			   { "utextureCubeArray", "keyword" },
			   { "textureBuffer", "keyword" },
			   { "itextureBuffer", "keyword" },
			   { "utextureBuffer", "keyword" },
			   { "sampler", "keyword2" },
			   { "samplerShadow", "keyword2" },
			   { "subpassInput", "keyword2" },
			   { "isubpassInput", "keyword2" },
			   { "usubpassInput", "keyword2" },
			   { "subpassInputMS", "keyword2" },
			   { "isubpassInputMS", "keyword2" },
			   { "usubpassInputMS", "keyword2" },
		   },
		   "//" } );

	// ini / conf
	add( { "Config File",
		   { "%.ini$", "%.conf$", "%.desktop$", "%.service$", "%.cfg$", "%.env$", "%.properties$",
			 "Doxyfile" },
		   { { { "^#.-\n" }, "comment" },
			 { { "%s#.-\n" }, "comment" },
			 { { "%s?#%x+" }, "string" },
			 { { "[%a_][%w-+_%s%p]-%f[=]" }, "keyword" },
			 { { "\"", "\"", "\\" }, "string" },
			 { { "'", "'", "\\" }, "string" },
			 { { "^%[.-%]" }, "keyword2" },
			 { { "%s%[.-%]" }, "keyword2" },
			 { { "=" }, "operator" },
			 { { "https?://(([%w_.~!*:@&+$/?%%#-]-)(%w[-.%w]*%.)(%w%w%w?%w?)(:?)(%d*)(/"
				 "?)([%w_.~!*:@&+$/?%%#=-]*))" },
			   "link" },
			 { { "[a-z]+" }, "symbol" } },
		   { { "true", "literal" }, { "false", "literal" } },
		   "#",
		   { "^%[.-%]" } } );

	// Makefile
	add( { "Makefile",
		   { "Makefile", "makefile", "%.mk$", "%.make$" },
		   {
			   { { "#.*\n" }, "comment" },
			   { { "[[.]]}" }, "normal" },
			   { { "$[@^<%%?+|*]" }, "keyword2" },
			   { { "$%(", "%)" }, "keyword" },
			   { { "%f[%w_][%d%.]+%f[^%w_]" }, "number" },
			   { { "%..*:" }, "keyword2" },
			   { { ".*:=" }, "function" },
			   { { ".*+=" }, "function" },
			   { { ".*%s=" }, "function" },
		   },
		   {},
		   "#" } );

	// C#
	add( { "C#",
		   { "%.cs$" },
		   {
			   { { "//.-\n" }, "comment" },
			   { { "/%*", "%*/" }, "comment" },
			   { { "\"", "\"", "\\" }, "string" },
			   { { "[%$%@]?\"", "\"", "\\" }, "string" },
			   { { "'\\x%x?%x?%x?%x'" }, "string" },
			   { { "'\\u%x%x%x%x'" }, "string" },
			   { { "'\\?.'" }, "string" },
			   { { "-?0x%x+" }, "number" },
			   { { "-?%d+[%d%.eE]*f?" }, "number" },
			   { { "-?%.?%d+f?" }, "number" },
			   { { "[%+%-=/%*%^%%<>!~|&]" }, "operator" },
			   { { "%?%?" }, "operator" },
			   { { "%?%." }, "operator" },
			   { { "[%a_][%w_]*%f[(]" }, "function" },
			   { { "[%a_][%w_]*" }, "symbol" },
		   },
		   { { "abstract", "keyword" },	 { "as", "keyword" },		 { "await", "keyword" },
			 { "base", "keyword" },		 { "break", "keyword" },	 { "case", "keyword" },
			 { "catch", "keyword" },	 { "checked", "keyword" },	 { "class", "keyword" },
			 { "const", "keyword" },	 { "continue", "keyword" },	 { "default", "keyword" },
			 { "delegate", "keyword" },	 { "do", "keyword" },		 { "else", "keyword" },
			 { "enum", "keyword" },		 { "event", "keyword" },	 { "explicit", "keyword" },
			 { "extern", "keyword" },	 { "finally", "keyword" },	 { "fixed", "keyword" },
			 { "for", "keyword" },		 { "foreach", "keyword" },	 { "get", "keyword" },
			 { "goto", "keyword" },		 { "if", "keyword" },		 { "implicit", "keyword" },
			 { "in", "keyword" },		 { "interface", "keyword" }, { "internal", "keyword" },
			 { "is", "keyword" },		 { "lock", "keyword" },		 { "namespace", "keyword" },
			 { "new", "keyword" },		 { "operator", "keyword" },	 { "out", "keyword" },
			 { "override", "keyword" },	 { "params", "keyword" },	 { "private", "keyword" },
			 { "protected", "keyword" }, { "public", "keyword" },	 { "readonly", "keyword" },
			 { "ref", "keyword" },		 { "return", "keyword" },	 { "sealed", "keyword" },
			 { "set", "keyword" },		 { "sizeof", "keyword" },	 { "stackalloc", "keyword" },
			 { "static", "keyword" },	 { "struct", "keyword" },	 { "switch", "keyword" },
			 { "this", "keyword" },		 { "throw", "keyword" },	 { "try", "keyword" },
			 { "typeof", "keyword" },	 { "unchecked", "keyword" }, { "unsafe", "keyword" },
			 { "using", "keyword" },	 { "var", "keyword" },		 { "virtual", "keyword" },
			 { "void", "keyword" },		 { "volatile", "keyword" },	 { "where", "keyword" },
			 { "while", "keyword" },	 { "yield", "keyword" },	 { "bool", "keyword2" },
			 { "byte", "keyword2" },	 { "char", "keyword2" },	 { "decimal", "keyword2" },
			 { "double", "keyword2" },	 { "float", "keyword2" },	 { "int", "keyword2" },
			 { "long", "keyword2" },	 { "object", "keyword2" },	 { "sbyte", "keyword2" },
			 { "short", "keyword2" },	 { "string", "keyword2" },	 { "uint", "keyword2" },
			 { "ulong", "keyword2" },	 { "ushort", "keyword2" },	 { "true", "literal" },
			 { "false", "literal" },	 { "null", "literal" },		 { "add", "keyword" },
			 { "record", "keyword" },	 { "remove", "keyword" },	 { "partial", "keyword" },
			 { "dynamic", "keyword" },	 { "value", "keyword" },	 { "global", "keyword" },
			 { "when", "keyword" } },
		   "//" } );

	// Go
	add( { "Go",
		   { "%.go$" },
		   {
			   { { "//.-\n" }, "comment" },
			   { { "/%*", "%*/" }, "comment" },
			   { { "\"", "\"", "\\" }, "string" },
			   { { "`", "`", "\\" }, "string" },
			   { { "0[oO_][0-7]+" }, "number" },
			   { { "-?0x[%x_]+" }, "number" },
			   { { "-?%d+_%d" }, "number" },
			   { { "-?%d+[%d%.eE]*f?" }, "number" },
			   { { "-?%.?%d+f?" }, "number" },
			   { { "[%+%-=/%*%^%%<>!~|&]" }, "operator" },
			   { { ":=" }, "operator" },
			   { { "[%a_][%w_]*%f[(]" }, "function" },
			   { { "[%a_][%w_]*" }, "symbol" },
		   },
		   {
			   { "if", "keyword" },		  { "else", "keyword" },	   { "elseif", "keyword" },
			   { "for", "keyword" },	  { "continue", "keyword" },   { "return", "keyword" },
			   { "struct", "keyword" },	  { "switch", "keyword" },	   { "case", "keyword" },
			   { "default", "keyword" },  { "const", "keyword" },	   { "package", "keyword" },
			   { "import", "keyword" },	  { "func", "keyword" },	   { "var", "keyword" },
			   { "type", "keyword" },	  { "interface", "keyword" },  { "select", "keyword" },
			   { "break", "keyword" },	  { "range", "keyword" },	   { "chan", "keyword" },
			   { "defer", "keyword" },	  { "go", "keyword" },		   { "fallthrough", "keyword" },
			   { "int", "keyword2" },	  { "int64", "keyword2" },	   { "int32", "keyword2" },
			   { "int16", "keyword2" },	  { "int8", "keyword2" },	   { "uint", "keyword2" },
			   { "uint64", "keyword2" },  { "uint32", "keyword2" },	   { "uint16", "keyword2" },
			   { "uint8", "keyword2" },	  { "uintptr", "keyword2" },   { "float64", "keyword2" },
			   { "float32", "keyword2" }, { "map", "keyword2" },	   { "string", "keyword2" },
			   { "rune", "keyword2" },	  { "bool", "keyword2" },	   { "byte", "keyword2" },
			   { "error", "keyword2" },	  { "complex64", "keyword2" }, { "complex128", "keyword2" },
			   { "true", "literal" },	  { "false", "literal" },	   { "nil", "literal" },
		   },
		   "//" } );

	// Rust
	add( { "Rust",
		   { "%.rs$" },
		   {
			   { { "//.-\n" }, "comment" },
			   { { "/%*", "%*/" }, "comment" },
			   { { "\"", "\"", "\\" }, "string" },
			   { { "`", "`", "\\" }, "string" },
			   { { "0[oO_][0-7]+" }, "number" },
			   { { "-?0x[%x_]+" }, "number" },
			   { { "-?%d+_%d" }, "number" },
			   { { "-?%d+[%d%.eE]*f?" }, "number" },
			   { { "-?%.?%d+f?" }, "number" },
			   { { "[%+%-=/%*%^%%<>!~|&]" }, "operator" },
			   { { "[%a_][%w_]*%f[(]" }, "function" },
			   { { "[%a_][%w_]*" }, "symbol" },
		   },
		   {
			   { "as", "keyword" },		{ "async", "keyword" },	  { "await", "keyword" },
			   { "break", "keyword" },	{ "const", "keyword" },	  { "continue", "keyword" },
			   { "crate", "keyword" },	{ "dyn", "keyword" },	  { "else", "keyword" },
			   { "enum", "keyword" },	{ "extern", "keyword" },  { "false", "keyword" },
			   { "fn", "keyword" },		{ "for", "keyword" },	  { "if", "keyword" },
			   { "impl", "keyword" },	{ "in", "keyword" },	  { "let", "keyword" },
			   { "loop", "keyword" },	{ "match", "keyword" },	  { "mod", "keyword" },
			   { "move", "keyword" },	{ "mut", "keyword" },	  { "pub", "keyword" },
			   { "ref", "keyword" },	{ "return", "keyword" },  { "Self", "keyword" },
			   { "self", "keyword" },	{ "static", "keyword" },  { "struct", "keyword" },
			   { "super", "keyword" },	{ "trait", "keyword" },	  { "true", "keyword" },
			   { "type", "keyword" },	{ "unsafe", "keyword" },  { "use", "keyword" },
			   { "where", "keyword" },	{ "while", "keyword" },	  { "i32", "keyword2" },
			   { "i64", "keyword2" },	{ "i128", "keyword2" },	  { "i16", "keyword2" },
			   { "i8", "keyword2" },	{ "u8", "keyword2" },	  { "u16", "keyword2" },
			   { "u32", "keyword2" },	{ "u64", "keyword2" },	  { "usize", "keyword2" },
			   { "isize", "keyword2" }, { "f32", "keyword2" },	  { "f64", "keyword2" },
			   { "f128", "keyword2" },	{ "String", "keyword2" }, { "char", "keyword2" },
			   { "&str", "keyword2" },	{ "bool", "keyword2" },	  { "true", "literal" },
			   { "false", "literal" },	{ "None", "literal" },	  { "Some", "literal" },
			   { "Option", "literal" }, { "Result", "literal" },
		   },
		   "//" } );

	// GDScript
	add( { "GDScript",
		   { "%.gd$" },
		   {
			   { { "#.-\n" }, "comment" },
			   { { "\"", "\"", "\\" }, "string" },
			   { { "'", "'", "\\" }, "string" },
			   { { "-?0x%x*" }, "number" },
			   { { "-?%d+[%d%.e]*" }, "number" },
			   { { "-?%.?%d+" }, "number" },
			   { { "[%+%:%-=/%*%^%%<>!~|&]" }, "operator" },
			   { { "[%a_][%w_]*%f[(]" }, "function" },
			   { { "[%a_][%w_]*" }, "symbol" },
		   },
		   {
			   { "if", "keyword" },
			   { "elif", "keyword" },
			   { "else", "keyword" },
			   { "for", "keyword" },
			   { "while", "keyword" },
			   { "match", "keyword" },
			   { "break", "keyword" },
			   { "continue", "keyword" },
			   { "pass", "keyword" },
			   { "return", "keyword" },
			   { "class", "keyword" },
			   { "class_name", "keyword" },
			   { "extends", "keyword" },
			   { "is", "keyword" },
			   { "in", "keyword" },
			   { "as", "keyword" },
			   { "and", "keyword" },
			   { "or", "keyword" },
			   { "not", "keyword" },
			   { "self", "keyword" },
			   { "tool", "keyword" },
			   { "signal", "keyword" },
			   { "func", "keyword" },
			   { "static", "keyword" },
			   { "const", "keyword" },
			   { "enum", "keyword" },
			   { "var", "keyword" },
			   { "onready", "keyword" },
			   { "export", "keyword" },
			   { "setget", "keyword" },
			   { "breakpoint", "keyword" },
			   { "preload", "keyword" },
			   { "yield", "keyword" },
			   { "assert", "keyword" },
			   { "remote", "keyword" },
			   { "master", "keyword" },
			   { "puppet", "keyword" },
			   { "remotesync", "keyword" },
			   { "mastersync", "keyword" },
			   { "puppetsync", "keyword" },
			   { "void", "keyword2" },
			   { "int", "keyword2" },
			   { "float", "keyword2" },
			   { "bool", "keyword2" },
			   { "String", "keyword2" },
			   { "Vector2", "keyword2" },
			   { "Rect2", "keyword2" },
			   { "Vector3", "keyword2" },
			   { "Transform2D", "keyword2" },
			   { "Plane", "keyword2" },
			   { "Quat", "keyword2" },
			   { "AABB", "keyword2" },
			   { "Basis", "keyword2" },
			   { "Transform", "keyword2" },
			   { "Color", "keyword2" },
			   { "NodePath", "keyword2" },
			   { "RID", "keyword2" },
			   { "Object", "keyword2" },
			   { "Array", "keyword2" },
			   { "PoolByteArray", "keyword2" },
			   { "PoolIntArray", "keyword2" },
			   { "PoolRealArray", "keyword2" },
			   { "PoolStringArray", "keyword2" },
			   { "PoolVector2Array", "keyword2" },
			   { "PoolVector3Array", "keyword2" },
			   { "PoolColorArray", "keyword2" },
			   { "Dictionary", "keyword2" },
			   { "null", "literal" },
			   { "true", "literal" },
			   { "false", "literal" },
			   { "PI", "literal" },
			   { "TAU", "literal" },
			   { "INF", "literal" },
			   { "NAN", "literal" },
		   },
		   "#" } );

	// D
	add( { "D",
		   { "%.d$", "%.di$" },
		   {
			   { { "//.-\n" }, "comment" },
			   { { "/%*", "%*/" }, "comment" },
			   { { "/%+", "%+/" }, "comment" },
			   { { "`", "`", "\\" }, "string" },
			   { { "\"", "\"", "\\" }, "string" },
			   { { "'", "'", "\\" }, "string" },
			   { { "-?0x%x+" }, "number" },
			   { { "-?%d+[%d%.eE]*f?" }, "number" },
			   { { "-?%.?%d+f?" }, "number" },
			   { { "[%+%-=/%*%^%%<>!~|&%$]+" }, "operator" },
			   { { "[%a_][%w_]*!" }, "function" },
			   { { "[%a_][%w_]*" }, "symbol" },
			   { { "@safe" }, "keyword" },
			   { { "@trusted" }, "keyword" },
			   { { "@nogc" }, "keyword" },
		   },
		   {
			   { "abstract", "keyword" },
			   { "alias", "keyword" },
			   { "align", "keyword" },
			   { "asm", "keyword" },
			   { "assert", "keyword" },
			   { "auto", "keyword" },
			   { "body", "keyword" },
			   { "bool", "keyword2" },
			   { "break", "keyword" },
			   { "byte", "keyword2" },
			   { "case", "keyword" },
			   { "cast", "keyword" },
			   { "catch", "keyword" },
			   { "cdouble", "keyword2" },
			   { "cent", "keyword2" },
			   { "cfloat", "keyword2" },
			   { "char", "keyword2" },
			   { "class", "keyword" },
			   { "const", "keyword" },
			   { "continue", "keyword" },
			   { "creal", "keyword2" },
			   { "dchar", "keyword2" },
			   { "debug", "keyword" },
			   { "default", "keyword" },
			   { "delegate", "keyword" },
			   { "deprecated", "keyword" },
			   { "do", "keyword" },
			   { "double", "keyword2" },
			   { "else", "keyword" },
			   { "enum", "keyword" },
			   { "export", "keyword" },
			   { "extern", "keyword" },
			   { "false", "literal" },
			   { "final", "keyword" },
			   { "finally", "keyword" },
			   { "float", "keyword2" },
			   { "for", "keyword" },
			   { "foreach", "keyword" },
			   { "foreach_reverse", "keyword" },
			   { "function", "keyword" },
			   { "goto", "keyword" },
			   { "idouble", "keyword2" },
			   { "if", "keyword" },
			   { "ifloat", "keyword2" },
			   { "immutable", "keyword" },
			   { "import", "keyword" },
			   { "in", "keyword" },
			   { "inout", "keyword" },
			   { "int", "keyword2" },
			   { "interface", "keyword" },
			   { "invariant", "keyword" },
			   { "ireal", "keyword2" },
			   { "is", "keyword" },
			   { "lazy", "keyword" },
			   { "long", "keyword2" },
			   { "macro", "keyword" },
			   { "mixin", "keyword" },
			   { "module", "keyword" },
			   { "new", "keyword" },
			   { "nothrow", "keyword" },
			   { "null", "literal" },
			   { "out", "keyword" },
			   { "override", "keyword" },
			   { "package", "keyword" },
			   { "pragma", "keyword" },
			   { "private", "keyword" },
			   { "protected", "keyword" },
			   { "public", "keyword" },
			   { "pure", "keyword" },
			   { "real", "keyword2" },
			   { "ref", "keyword" },
			   { "return", "keyword" },
			   { "scope", "keyword" },
			   { "shared", "keyword" },
			   { "short", "keyword2" },
			   { "static", "keyword" },
			   { "struct", "keyword" },
			   { "super", "keyword" },
			   { "switch", "keyword" },
			   { "synchronized", "keyword" },
			   { "template", "keyword" },
			   { "this", "keyword" },
			   { "throw", "keyword" },
			   { "true", "literal" },
			   { "try", "keyword" },
			   { "typeid", "keyword" },
			   { "typeof", "keyword" },
			   { "ubyte", "keyword2" },
			   { "ucent", "keyword2" },
			   { "uint", "keyword2" },
			   { "ulong", "keyword2" },
			   { "union", "keyword" },
			   { "unittest", "keyword" },
			   { "ushort", "keyword2" },
			   { "version", "keyword" },
			   { "void", "keyword" },
			   { "wchar", "keyword2" },
			   { "while", "keyword" },
			   { "with", "keyword" },
			   { "__FILE__", "keyword" },
			   { "__FILE_FULL_PATH__", "keyword" },
			   { "__MODULE__", "keyword" },
			   { "__LINE__", "keyword" },
			   { "__FUNCTION__", "keyword" },
			   { "__PRETTY_FUNCTION__", "keyword" },
			   { "__gshared", "keyword" },
			   { "__traits", "keyword" },
			   { "__vector", "keyword" },
			   { "__parameters", "keyword" },
		   },
		   "//" } );

	// Haskell
	add( { "Haskell",
		   { "%.hs$" },
		   {
			   { { "%-%-", "\n" }, "comment" },
			   { { "{%-", "%-}" }, "comment" },
			   { { "\"", "\"", "\\" }, "string" },
			   { { "'", "'", "\\" }, "string" },
			   { { "-?0x%x+" }, "number" },
			   { { "-?%d+[%d%.eE]*f?" }, "number" },
			   { { "-?%.?%d+f?" }, "number" },
			   { { "[!%#%$%%&*+./%<=>%?@\\%^|%-~:]" }, "operator" },
			   { { "[%a_'][%w_']*" }, "symbol" },
		   },
		   {
			   { "as", "keyword" },		  { "case", "keyword" },	{ "of", "keyword" },
			   { "class", "keyword" },	  { "data", "keyword" },	{ "default", "keyword" },
			   { "deriving", "keyword" }, { "do", "keyword" },		{ "forall", "keyword" },
			   { "foreign", "keyword" },  { "hiding", "keyword" },	{ "if", "keyword" },
			   { "then", "keyword" },	  { "else", "keyword" },	{ "import", "keyword" },
			   { "infix", "keyword" },	  { "infixl", "keyword" },	{ "infixr", "keyword" },
			   { "let", "keyword" },	  { "in", "keyword" },		{ "mdo", "keyword" },
			   { "module", "keyword" },	  { "newtype", "keyword" }, { "qualified", "keyword" },
			   { "type", "keyword" },	  { "where", "keyword" },
		   },
		   "%-%-" } );

	// HLSL
	add( { "HLSL",
		   {
			   "%.hlsl$",
		   },
		   {
			   { { "//.-\n" }, "comment" },
			   { { "/%*", "%*/" }, "comment" },
			   { { "#", "[^\\]\n" }, "comment" },
			   { { "\"", "\"", "\\" }, "string" },
			   { { "'", "'", "\\" }, "string" },
			   { { "-?0x%x+" }, "number" },
			   { { "-?%d+[%d%.eE]*f?" }, "number" },
			   { { "-?%.?%d+f?" }, "number" },
			   { { "[%+%-=/%*%^%%<>!~|&]" }, "operator" },
			   { { "int[1-9]x[1-9]" }, "keyword2" },
			   { { "int1[0-6]x[1-9]" }, "keyword2" },
			   { { "int[1-9]x1[0-6]" }, "keyword2" },
			   { { "int1[0-6]x1[0-6]" }, "keyword2" },
			   { { "int[1-4]" }, "keyword2" },
			   { { "uint[1-9]x[1-9]" }, "keyword2" },
			   { { "uint1[0-6]x[1-9]" }, "keyword2" },
			   { { "uint[1-9]x1[0-6]" }, "keyword2" },
			   { { "uint1[0-6]x1[0-6]" }, "keyword2" },
			   { { "uint[1-4]" }, "keyword2" },
			   { { "dword[1-9]x[1-9]" }, "keyword2" },
			   { { "dword1[0-6]x[1-9]" }, "keyword2" },
			   { { "dword[1-9]x1[0-6]" }, "keyword2" },
			   { { "dword1[0-6]x1[0-6]" }, "keyword2" },
			   { { "dword[1-4]" }, "keyword2" },
			   { { "half[1-9]x[1-9]" }, "keyword2" },
			   { { "half1[0-6]x[1-9]" }, "keyword2" },
			   { { "half[1-9]x1[0-6]" }, "keyword2" },
			   { { "half1[0-6]x1[0-6]" }, "keyword2" },
			   { { "half[1-4]" }, "keyword2" },
			   { { "float[1-9]x[1-9]" }, "keyword2" },
			   { { "float1[0-6]x[1-9]" }, "keyword2" },
			   { { "float[1-9]x1[0-6]" }, "keyword2" },
			   { { "float1[0-6]x1[0-6]" }, "keyword2" },
			   { { "float[1-4]" }, "keyword2" },
			   { { "double[1-9]x[1-9]" }, "keyword2" },
			   { { "double1[0-6]x[1-9]" }, "keyword2" },
			   { { "double[1-9]x1[0-6]" }, "keyword2" },
			   { { "double1[0-6]x1[0-6]" }, "keyword2" },
			   { { "double[1-4]" }, "keyword2" },
			   { { "[%a_][%w_]*%f[(]" }, "function" },
			   { { "[%a_][%w_]*" }, "symbol" },
		   },
		   {
			   { "AppendStructuredBuffer", "keyword" },
			   { "asm", "keyword" },
			   { "asm_fragment", "keyword" },
			   { "BlendState", "keyword2" },
			   { "bool", "keyword2" },
			   { "break", "keyword" },
			   { "Buffer", "keyword2" },
			   { "ByteAddressBuffer", "keyword2" },
			   { "case", "keyword" },
			   { "cbuffer", "keyword2" },
			   { "centroid", "keyword2" },
			   { "class", "keyword" },
			   { "column_major", "keyword" },
			   { "compile", "keyword" },
			   { "compile_fragment", "keyword" },
			   { "CompileShader", "keyword" },
			   { "const", "keyword" },
			   { "continue", "keyword" },
			   { "ComputeShader", "keyword" },
			   { "ConsumeStructuredBuffer", "keyword" },
			   { "default", "keyword" },
			   { "DepthStencilState", "keyword" },
			   { "DepthStencilView", "keyword" },
			   { "discard", "keyword" },
			   { "do", "keyword" },
			   { "double", "keyword2" },
			   { "DomainShader", "keyword2" },
			   { "dword", "keyword2" },
			   { "else", "keyword" },
			   { "export", "keyword" },
			   { "extern", "keyword" },
			   { "false", "literal" },
			   { "float", "keyword2" },
			   { "for", "keyword" },
			   { "fxgroup", "keyword2" },
			   { "GeometryShader", "keyword2" },
			   { "groupshared", "keyword" },
			   { "half", "keyword2" },
			   { "HullShader", "keyword2" },
			   { "if", "keyword" },
			   { "in", "keyword" },
			   { "inline", "keyword" },
			   { "inout", "keyword" },
			   { "InputPatch", "keyword2" },
			   { "int", "keyword2" },
			   { "interface", "keyword" },
			   { "line", "keyword2" },
			   { "lineadj", "keyword2" },
			   { "linear", "keyword" },
			   { "LineStream", "keyword2" },
			   { "matrix", "keyword2" },
			   { "min16float", "keyword2" },
			   { "min10float", "keyword2" },
			   { "min16int", "keyword2" },
			   { "min12int", "keyword2" },
			   { "min16uint", "keyword2" },
			   { "namespace", "keyword" },
			   { "nointerpolation", "keyword" },
			   { "noperspective", "keyword" },
			   { "NULL", "literal" },
			   { "out", "keyword" },
			   { "OutputPatch", "keyword2" },
			   { "packoffset", "keyword" },
			   { "pass", "keyword" },
			   { "pixelfragment", "keyword" },
			   { "PixelShader", "keyword2" },
			   { "point", "keyword2" },
			   { "PointStream", "keyword2" },
			   { "precise", "keyword" },
			   { "RasterizerState", "keyword2" },
			   { "RenderTargetView", "keyword2" },
			   { "return", "keyword" },
			   { "register", "keyword" },
			   { "row_major", "keyword" },
			   { "RWBuffer", "keyword2" },
			   { "RWByteAddressBuffer", "keyword2" },
			   { "RWStructuredBuffer", "keyword2" },
			   { "RWTexture1D", "keyword2" },
			   { "RWTexture1DArray", "keyword2" },
			   { "RWTexture2D", "keyword2" },
			   { "RWTexture2DArray", "keyword2" },
			   { "RWTexture3D", "keyword2" },
			   { "sample", "keyword" },
			   { "sampler", "keyword2" },
			   { "SamplerState", "keyword2" },
			   { "SamplerComparisonState", "keyword2" },
			   { "shared", "keyword" },
			   { "snorm", "keyword" },
			   { "stateblock", "keyword" },
			   { "stateblock_state", "keyword" },
			   { "static", "keyword" },
			   { "string", "keyword2" },
			   { "struct", "keyword" },
			   { "switch", "keyword" },
			   { "StructuredBuffer", "keyword2" },
			   { "tbuffer", "keyword2" },
			   { "technique", "keyword2" },
			   { "technique10", "keyword2" },
			   { "technique11", "keyword2" },
			   { "texture", "keyword2" },
			   { "Texture1D", "keyword2" },
			   { "Texture1DArray", "keyword2" },
			   { "Texture2D", "keyword2" },
			   { "Texture2DArray", "keyword2" },
			   { "Texture2DMS", "keyword2" },
			   { "Texture2DMSArray", "keyword2" },
			   { "Texture3D", "keyword2" },
			   { "TextureCube", "keyword2" },
			   { "TextureCubeArray", "keyword2" },
			   { "true", "literal" },
			   { "typedef", "keyword" },
			   { "triangle", "keyword2" },
			   { "triangleadj", "keyword2" },
			   { "TriangleStream", "keyword2" },
			   { "uint", "keyword2" },
			   { "uniform", "keyword" },
			   { "unorm", "keyword" },
			   { "unsigned", "keyword" },
			   { "vector", "keyword2" },
			   { "vertexfragment", "keyword2" },
			   { "VertexShader", "keyword2" },
			   { "void", "keyword" },
			   { "volatile", "keyword" },
			   { "while", "keyword" },
			   { "abort", "keyword" },
			   { "abs", "keyword" },
			   { "acos", "keyword" },
			   { "all", "keyword" },
			   { "any", "keyword" },
			   { "asdouble", "keyword" },
			   { "asfloat", "keyword" },
			   { "asin", "keyword" },
			   { "asint", "keyword" },
			   { "asuint", "keyword" },
			   { "atan", "keyword" },
			   { "atan2", "keyword" },
			   { "ceil", "keyword" },
			   { "clamp", "keyword" },
			   { "clip", "keyword" },
			   { "cos", "keyword" },
			   { "cosh", "keyword" },
			   { "countbits", "keyword" },
			   { "cross", "keyword" },
			   { "ddx", "keyword" },
			   { "ddx_coarse", "keyword" },
			   { "ddx_fine", "keyword" },
			   { "ddy", "keyword" },
			   { "ddy_coarse", "keyword" },
			   { "ddy_fine", "keyword" },
			   { "degrees", "keyword" },
			   { "determinant", "keyword" },
			   { "distance", "keyword" },
			   { "dot", "keyword" },
			   { "dst", "keyword" },
			   { "errorf", "keyword" },
			   { "exp", "keyword" },
			   { "exp2", "keyword" },
			   { "f16tof32", "keyword" },
			   { "f32tof16", "keyword" },
			   { "faceforward", "keyword" },
			   { "firstbithigh", "keyword" },
			   { "firstbitlow", "keyword" },
			   { "floor", "keyword" },
			   { "fma", "keyword" },
			   { "fmod", "keyword" },
			   { "frac", "keyword" },
			   { "frexp", "keyword" },
			   { "fwidth", "keyword" },
			   { "isfinite", "keyword" },
			   { "isinf", "keyword" },
			   { "isnan", "keyword" },
			   { "ldexp", "keyword" },
			   { "length", "keyword" },
			   { "lerp", "keyword" },
			   { "lit", "keyword" },
			   { "log", "keyword" },
			   { "log10", "keyword" },
			   { "log2", "keyword" },
			   { "mad", "keyword" },
			   { "max", "keyword" },
			   { "min", "keyword" },
			   { "modf", "keyword" },
			   { "msad4", "keyword" },
			   { "mul", "keyword" },
			   { "noise", "keyword" },
			   { "normalize", "keyword" },
			   { "pow", "keyword" },
			   { "printf", "keyword" },
			   { "radians", "keyword" },
			   { "rcp", "keyword" },
			   { "reflect", "keyword" },
			   { "refract", "keyword" },
			   { "reversebits", "keyword" },
			   { "round", "keyword" },
			   { "rsqrt", "keyword" },
			   { "saturate", "keyword" },
			   { "sign", "keyword" },
			   { "sin", "keyword" },
			   { "sincos", "keyword" },
			   { "sinh", "keyword" },
			   { "smoothstep", "keyword" },
			   { "sqrt", "keyword" },
			   { "step", "keyword" },
			   { "tan", "keyword" },
			   { "tanh", "keyword" },
			   { "transpose", "keyword" },
			   { "trunc", "keyword" },
		   },
		   "//" } );

	// LaTeX
	add( { "LaTeX",
		   { "%.tex$" },
		   {
			   { { "%%", "\n" }, "comment" },
			   { { "&" }, "operator" },
			   { { "\\\\" }, "operator" },
			   { { "%$", "%$" }, "operator" },
			   { { "\\%[", "\\]" }, "operator" },
			   { { "{", "}" }, "keyword" },
			   { { "\\%w*" }, "keyword2" },
		   },
		   {},
		   "%%" } );

	// Meson
	add( { "Meson",
		   { "meson.build$" },
		   {
			   { { "#", "\n" }, "comment" },
			   { { "\"", "\"", "\\" }, "string" },
			   { { "'", "'", "\\" }, "string" },
			   { { "'''", "'''" }, "string" },
			   { { "0x[%da-fA-F]+" }, "number" },
			   { { "-?%d+%d*" }, "number" },
			   { { "[%+%-=/%%%*!]" }, "operator" },
			   { { "[%a_][%w_]*%f[(]" }, "function" },
			   { { "[%a_][%w_]*" }, "symbol" },
		   },
		   {
			   { "if", "keyword" },
			   { "then", "keyword" },
			   { "else", "keyword" },
			   { "elif", "keyword" },
			   { "endif", "keyword" },
			   { "foreach", "keyword" },
			   { "endforeach", "keyword" },
			   { "break", "keyword" },
			   { "continue", "keyword" },
			   { "and", "keyword" },
			   { "not", "keyword" },
			   { "or", "keyword" },
			   { "in", "keyword" },
			   { "true", "literal" },
			   { "false", "literal" },
		   },
		   "#" } );

	// AngelScript
	add( { "AlgelScript",
		   { "%.as$", "%.asc$" },
		   {
			   { { "//.-\n" }, "comment" },
			   { { "/%*", "%*/" }, "comment" },
			   { { "#", "[^\\]\n" }, "comment" },
			   { { "\"", "\"", "\\" }, "string" },
			   { { "'", "'", "\\" }, "string" },
			   { { "-?0[xX]%x+" }, "number" },
			   { { "-?0[bB][0-1]+" }, "number" },
			   { { "-?0[oO][0-7]+" }, "number" },
			   { { "-?%d+[%d%.eE]*f?" }, "number" },
			   { { "-?%.?%d+f?" }, "number" },
			   { { "&inout" }, "keyword" },
			   { { "&in" }, "keyword" },
			   { { "&out" }, "keyword" },
			   { { "[%a_][%w_]*@" }, "keyword2" },
			   { { "[%-%+!~@%?:&|%^<>%*/=%%]" }, "operator" },
			   { { "[%a_][%w_]*%f[(]" }, "function" },
			   { { "[%a_][%w_]*" }, "symbol" },
		   },
		   {
			   { "shared", "keyword" },	   { "external", "keyword" },  { "private", "keyword" },
			   { "protected", "keyword" }, { "const", "keyword" },	   { "final", "keyword" },
			   { "abstract", "keyword" },  { "class", "keyword" },	   { "typedef", "keyword" },
			   { "namespace", "keyword" }, { "interface", "keyword" }, { "import", "keyword" },
			   { "enum", "keyword" },	   { "funcdef", "keyword" },   { "get", "keyword" },
			   { "set", "keyword" },	   { "mixin", "keyword" },	   { "void", "keyword2" },
			   { "int", "keyword2" },	   { "int8", "keyword2" },	   { "int16", "keyword2" },
			   { "int32", "keyword2" },	   { "int64", "keyword2" },	   { "uint", "keyword2" },
			   { "uint8", "keyword2" },	   { "uint16", "keyword2" },   { "uint32", "keyword2" },
			   { "uint64", "keyword2" },   { "float", "keyword2" },	   { "double", "keyword2" },
			   { "bool", "keyword2" },	   { "auto", "keyword" },	   { "override", "keyword" },
			   { "explicit", "keyword" },  { "property", "keyword" },  { "break", "keyword" },
			   { "continue", "keyword" },  { "return", "keyword" },	   { "switch", "keyword" },
			   { "case", "keyword" },	   { "default", "keyword" },   { "for", "keyword" },
			   { "while", "keyword" },	   { "do", "keyword" },		   { "if", "keyword" },
			   { "else", "keyword" },	   { "try", "keyword" },	   { "catch", "keyword" },
			   { "cast", "keyword" },	   { "function", "keyword" },  { "true", "literal" },
			   { "false", "literal" },	   { "null", "literal" },	   { "is", "operator" },
			   { "and", "operator" },	   { "or", "operator" },	   { "xor", "operator" },
		   },
		   "//" } );

	// Batch script
	std::unordered_map<std::string, std::vector<std::string>> batchSymTable = {
		{ "keyword",
		  {
			  "if",			"else",			 "elsif", "not",  "for",	"do",	"in",	 "equ",
			  "neq",		"lss",			 "leq",	  "gtr",  "geq",	"nul",	"con",	 "prn",
			  "prn",		"lpt1",			 "com1",  "com2", "com3",	"com4", "exist", "defined",
			  "errorlevel", "cmdextversion", "goto",  "call", "verify",
		  } },
		{ "function",
		  {
			  "set",	"setlocal", "endlocal", "enabledelayedexpansion",
			  "echo",	"type",		"cd",		"chdir",
			  "md",		"mkdir",	"pause",	"choice",
			  "exit",	"del",		"rd",		"rmdir",
			  "copy",	"xcopy",	"move",		"ren",
			  "find",	"findstr",	"sort",		"shift",
			  "attrib", "cmd",		"command",	"forfiles",
		  } } };

	auto prepareBatchSymbols = []( std::unordered_map<std::string, std::vector<std::string>> table )
		-> std::unordered_map<std::string, std::string> {
		std::unordered_map<std::string, std::string> symbols;
		for ( auto& el : table ) {
			for ( const auto& it : el.second ) {
				symbols[String::toLower( it )] = el.first;
				symbols[String::toUpper( it )] = el.first;
			}
		}
		return symbols;
	};

	add( { "Batch script",
		   { "%.bat$", "%.cmd$" },
		   {
			   { { "@echo off\n" }, "keyword" },
			   { { "@echo on\n" }, "keyword" },
			   { { "rem.-\n" }, "comment" },
			   { { "REM.-\n" }, "comment" },
			   { { "%s*:[%w%-]+" }, "symbol" },
			   { { "%:%:.-\n" }, "comment" },
			   { { "%%%w+%%" }, "symbol" },
			   { { "%%%%?~?[%w:]+" }, "symbol" },
			   { { "[!=()%>&%^/\\@]" }, "operator" },
			   { { "-?%.?%d+f?" }, "number" },
			   { { "\"", "\"", "\\" }, "string" },
			   { { "[%a_][%w_]*" }, "normal" },
			   { { ":eof" }, "keyword" },
		   },
		   prepareBatchSymbols( batchSymTable ),
		   "rem" } );

	// diff - patch
	add( { "Diff File",
		   { "%.diff$", "%.patch$" },
		   {
			   { { "^%+%+%+%s.-\n" }, "keyword" },
			   { { "^%-%-%-%s.-\n" }, "keyword" },
			   { { "^diff%s.-\n" }, "string" },
			   { { "^index%s.-\n" }, "comment" },
			   { { "^@@.-\n" }, "number" },
			   { { "^%+.-\n" }, "function" },
			   { { "^%-.-\n" }, "keyword2" },
		   } } );

	// Add Java
	add(
		{ "Java",
		  { "%.java$" },
		  {
			  { { "//.-\n" }, "comment" },
			  { { "/%*", "%*/" }, "comment" },
			  { { "\"", "\"", "\\" }, "string" },
			  { { "'", "'", "\\" }, "string" },
			  { { "'\\x%x?%x?%x?%x'" }, "string" },
			  { { "'\\u%x%x%x%x'" }, "string" },
			  { { "'\\?.'" }, "string" },
			  { { "-?0x%x+" }, "number" },
			  { { "-?%d+[%d%.eE]*f?" }, "number" },
			  { { "-?%.?%d+f?" }, "number" },
			  { { "[%+%-=/%*%^%%<>!~|&]" }, "operator" },
			  { { "[%a_][%w_]*%f[(]" }, "function" },
			  { { "[%a_][%w_]*" }, "symbol" },
		  },
		  {
			  { "if", "keyword" },		 { "then", "keyword" },			{ "else", "keyword" },
			  { "elseif", "keyword" },	 { "do", "keyword" },			{ "while", "keyword" },
			  { "for", "keyword" },		 { "new", "keyword" },			{ "break", "keyword" },
			  { "continue", "keyword" }, { "return", "keyword" },		{ "goto", "keyword" },
			  { "class", "keyword" },	 { "implements", "keyword" },	{ "extends", "keyword" },
			  { "private", "keyword" },	 { "protected", "keyword" },	{ "public", "keyword" },
			  { "abstract", "keyword" }, { "interface", "keyword" },	{ "assert", "keyword" },
			  { "import", "keyword" },	 { "native", "keyword" },		{ "package", "keyword" },
			  { "super", "keyword" },	 { "synchronized", "keyword" }, { "instanceof", "keyword" },
			  { "enum", "keyword" },	 { "catch", "keyword" },		{ "throw", "keyword" },
			  { "throws", "keyword" },	 { "try", "keyword" },			{ "transient", "keyword" },
			  { "finally", "keyword" },	 { "static", "keyword" },		{ "volatile", "keyword" },
			  { "final", "keyword" },	 { "switch", "keyword" },		{ "case", "keyword" },
			  { "default", "keyword" },	 { "void", "keyword" },			{ "int", "keyword2" },
			  { "short", "keyword2" },	 { "byte", "keyword2" },		{ "long", "keyword2" },
			  { "float", "keyword2" },	 { "double", "keyword2" },		{ "char", "keyword2" },
			  { "boolean", "keyword2" }, { "true", "literal" },			{ "false", "literal" },
			  { "null", "literal" },
		  },
		  "//" } );

	// YAML
	add( { "YAML",
		   { "%.yml$", "%.yaml$" },
		   {
			   { { "^#.-\n" }, "comment" },
			   { { "%s#.-\n" }, "comment" },
			   { { "\"", "\"", "\\" }, "string" },
			   { { "'", "'", "\\" }, "string" },
			   { { "!!str", "\n", "\\" }, "string" },
			   { { "%s-%-%s+.*\n" }, "keyword2" },
			   { { "%s+[%w%s-_]+:%s+" }, "keyword" },
			   { { "^[%w%s-_]+:%s+" }, "keyword" },
			   { { "%f[%S]%-?0x%x+" }, "number" },
			   { { "%f[%S]%-?%d+[%d%.eE]*f?" }, "number" },
			   { { "%f[%S]%-?%.?%d+f?" }, "number" },
			   { { "!!float", "\n", "\\" }, "number" },
			   { { "https?://(([%w_.~!*:@&+$/?%%#-]-)(%w[-.%w]*%.)(%w%w%w?%w?)(:?)(%d*)(/"
				   "?)([%w_.~!*:@&+$/?%%#=-]*))" },
				 "link" },
			   { { "%-%-%-" }, "literal" },
		   },
		   {},
		   "#" } );

	// Swift
	add( { "Swift",
		   { "%.swift$" },
		   {
			   { { "//.-\n" }, "comment" },
			   { { "/%*", "%*/" }, "comment" },
			   { { "\"\"\"", "\"\"\"" }, "string" },
			   { { "\"", "\"", "\\" }, "string" },
			   { { "-?0x%x+" }, "number" },
			   { { "-?%d+[%d%.eE]*f?" }, "number" },
			   { { "-?%.?%d+f?" }, "number" },
			   { { "[%+%-=/%*%^%%<>!~|&]" }, "operator" },
			   { { "[%a_][%w_]*%f[(]" }, "function" },
			   { { "[%a_][%w_]*[?!]?" }, "symbol" },
		   },
		   {
			   { "#available", "keyword" },
			   { "#colorLiteral", "keyword" },
			   { "#column", "keyword" },
			   { "#else", "keyword" },
			   { "#elseif", "keyword" },
			   { "#endif", "keyword" },
			   { "#file", "keyword" },
			   { "#fileLiteral", "keyword" },
			   { "#function", "keyword" },
			   { "#if", "keyword" },
			   { "#imageLiteral", "keyword" },
			   { "#line", "keyword" },
			   { "#selector", "keyword" },
			   { "#sourceLocation", "keyword" },
			   { "_", "keyword" },
			   { "__COLUMN__", "keyword" },
			   { "__FILE__", "keyword" },
			   { "__FUNCTION__", "keyword" },
			   { "__LINE__", "keyword" },
			   { "Any", "keyword" },
			   { "as", "keyword" },
			   { "as!", "keyword" },
			   { "as?", "keyword" },
			   { "associatedtype", "keyword" },
			   { "associativity", "keyword" },
			   { "break", "keyword" },
			   { "case", "keyword" },
			   { "catch", "keyword" },
			   { "class", "keyword" },
			   { "continue", "keyword" },
			   { "convenience", "keyword" },
			   { "default", "keyword" },
			   { "defer", "keyword" },
			   { "deinit", "keyword" },
			   { "didSet", "keyword" },
			   { "do", "keyword" },
			   { "dynamic", "keyword" },
			   { "dynamicType", "keyword" },
			   { "else", "keyword" },
			   { "enum", "keyword" },
			   { "extension", "keyword" },
			   { "fallthrough", "keyword" },
			   { "false", "keyword" },
			   { "fileprivate", "keyword" },
			   { "final", "keyword" },
			   { "for", "keyword" },
			   { "func", "keyword" },
			   { "get", "keyword" },
			   { "guard", "keyword" },
			   { "if", "keyword" },
			   { "import", "keyword" },
			   { "in", "keyword" },
			   { "indirect", "keyword" },
			   { "infix", "keyword" },
			   { "init", "keyword" },
			   { "inout", "keyword" },
			   { "internal", "keyword" },
			   { "is", "keyword" },
			   { "lazy", "keyword" },
			   { "left", "keyword" },
			   { "let", "keyword" },
			   { "mutating", "keyword" },
			   { "nil", "keyword" },
			   { "none", "keyword" },
			   { "nonmutating", "keyword" },
			   { "open", "keyword" },
			   { "operator", "keyword" },
			   { "optional", "keyword" },
			   { "override", "keyword" },
			   { "postfix", "keyword" },
			   { "precedence", "keyword" },
			   { "prefix", "keyword" },
			   { "private", "keyword" },
			   { "protocol", "keyword" },
			   { "Protocol", "keyword" },
			   { "public", "keyword" },
			   { "repeat", "keyword" },
			   { "required", "keyword" },
			   { "rethrows", "keyword" },
			   { "return", "keyword" },
			   { "right", "keyword" },
			   { "self", "keyword" },
			   { "Self", "keyword" },
			   { "set", "keyword" },
			   { "static", "keyword" },
			   { "struct", "keyword" },
			   { "subscript", "keyword" },
			   { "super", "keyword" },
			   { "switch", "keyword" },
			   { "throw", "keyword" },
			   { "throws", "keyword" },
			   { "true", "keyword" },
			   { "try", "keyword" },
			   { "try!", "keyword" },
			   { "try?", "keyword" },
			   { "Type", "keyword" },
			   { "typealias", "keyword" },
			   { "unowned", "keyword" },
			   { "var", "keyword" },
			   { "weak", "keyword" },
			   { "where", "keyword" },
			   { "while", "keyword" },
			   { "willSet", "keyword" },
			   { "true", "literal" },
			   { "false", "literal" },
			   { "nil", "literal" },
			   { "abs", "keyword2" },
			   { "advance", "keyword2" },
			   { "alignof", "keyword2" },
			   { "alignofValue", "keyword2" },
			   { "anyGenerator", "keyword2" },
			   { "assert", "keyword2" },
			   { "assertionFailure", "keyword2" },
			   { "bridgeFromObjectiveC", "keyword2" },
			   { "bridgeFromObjectiveCUnconditional", "keyword2" },
			   { "bridgeToObjectiveC", "keyword2" },
			   { "bridgeToObjectiveCUnconditional", "keyword2" },
			   { "c", "keyword2" },
			   { "compactMap", "keyword2" },
			   { "contains", "keyword2" },
			   { "count", "keyword2" },
			   { "countElements", "keyword2" },
			   { "countLeadingZeros", "keyword2" },
			   { "debugPrint", "keyword2" },
			   { "debugPrintln", "keyword2" },
			   { "distance", "keyword2" },
			   { "dropFirst", "keyword2" },
			   { "dropLast", "keyword2" },
			   { "dump", "keyword2" },
			   { "encodeBitsAsWords", "keyword2" },
			   { "enumerate", "keyword2" },
			   { "equal", "keyword2" },
			   { "fatalError", "keyword2" },
			   { "filter", "keyword2" },
			   { "find", "keyword2" },
			   { "getBridgedObjectiveCType", "keyword2" },
			   { "getVaList", "keyword2" },
			   { "indices", "keyword2" },
			   { "insertionSort", "keyword2" },
			   { "isBridgedToObjectiveC", "keyword2" },
			   { "isBridgedVerbatimToObjectiveC", "keyword2" },
			   { "isUniquelyReferenced", "keyword2" },
			   { "isUniquelyReferencedNonObjC", "keyword2" },
			   { "join", "keyword2" },
			   { "lazy", "keyword2" },
			   { "lexicographicalCompare", "keyword2" },
			   { "map", "keyword2" },
			   { "max", "keyword2" },
			   { "maxElement", "keyword2" },
			   { "min", "keyword2" },
			   { "minElement", "keyword2" },
			   { "numericCast", "keyword2" },
			   { "overlaps", "keyword2" },
			   { "partition", "keyword2" },
			   { "posix", "keyword2" },
			   { "precondition", "keyword2" },
			   { "preconditionFailure", "keyword2" },
			   { "print", "keyword2" },
			   { "println", "keyword2" },
			   { "quickSort", "keyword2" },
			   { "readLine", "keyword2" },
			   { "reduce", "keyword2" },
			   { "reflect", "keyword2" },
			   { "reinterpretCast", "keyword2" },
			   { "reverse", "keyword2" },
			   { "roundUpToAlignment", "keyword2" },
			   { "sizeof", "keyword2" },
			   { "sizeofValue", "keyword2" },
			   { "sort", "keyword2" },
			   { "split", "keyword2" },
			   { "startsWith", "keyword2" },
			   { "stride", "keyword2" },
			   { "strideof", "keyword2" },
			   { "strideofValue", "keyword2" },
			   { "swap", "keyword2" },
			   { "toString", "keyword2" },
			   { "transcode", "keyword2" },
			   { "underestimateCount", "keyword2" },
			   { "unsafeAddressOf", "keyword2" },
			   { "unsafeBitCast", "keyword2" },
			   { "unsafeDowncast", "keyword2" },
			   { "unsafeUnwrap", "keyword2" },
			   { "unsafeReflect", "keyword2" },
			   { "withExtendedLifetime", "keyword2" },
			   { "withObjectAtPlusZero", "keyword2" },
			   { "withUnsafePointer", "keyword2" },
			   { "withUnsafePointerToObject", "keyword2" },
			   { "withUnsafeMutablePointer", "keyword2" },
			   { "withUnsafeMutablePointers", "keyword2" },
			   { "withUnsafePointer", "keyword2" },
			   { "withUnsafePointers", "keyword2" },
			   { "withVaList", "keyword2" },
			   { "zip", "keyword2" },
			   { "Int", "keyword2" },
			   { "Float", "keyword2" },
			   { "Double", "keyword2" },
			   { "String", "keyword2" },
			   { "Void", "keyword2" },
			   { "Bool", "keyword2" },
			   { "Array", "keyword2" },
			   { "Optional", "keyword2" },
		   },
		   "//" } );

	add( { "Solidity",
		   { "%.sol$" },
		   {
			   { { "//.-\n" }, "comment" },
			   { { "/%*", "%*/" }, "comment" },
			   { { "\"\"\"", "\"\"\"" }, "string" },
			   { { "\"", "\"", "\\" }, "string" },
			   { { "-?0x%x+" }, "number" },
			   { { "-?%d+[%d%.eE]*f?" }, "number" },
			   { { "-?%.?%d+f?" }, "number" },
			   { { "[%+%-=/%*%^%%<>!~|&]" }, "operator" },
			   { { "[%a_][%w_]*%f[(]" }, "function" },
			   { { "[%a_][%w_]*" }, "symbol" },
		   },
		   { { "if", "keyword" },		   { "else", "keyword" },
			 { "for", "keyword" },		   { "while", "keyword" },
			 { "do", "keyword" },		   { "break", "keyword" },
			 { "continue", "keyword" },	   { "throw", "keyword" },
			 { "returns", "keyword" },	   { "return", "keyword" },
			 { "function", "keyword" },	   { "private", "keyword2" },
			 { "public", "keyword2" },	   { "internal", "keyword2" },
			 { "external", "keyword2" },   { "constant", "keyword2" },
			 { "immutable", "keyword2" },  { "pure", "keyword2" },
			 { "view", "keyword2" },	   { "payable", "keyword2" },
			 { "nonpayable", "keyword2" }, { "inherited", "keyword2" },
			 { "indexed", "keyword2" },	   { "storage", "keyword2" },
			 { "memory", "keyword2" },	   { "virtual", "keyword2" },
			 { "calldata", "keyword2" },   { "override", "keyword2" },
			 { "abstract", "keyword" },	   { "library", "keyword" },
			 { "enum", "keyword" },		   { "constructor", "keyword" },
			 { "event", "keyword" },	   { "modifier", "keyword" },
			 { "assembly", "keyword" },	   { "let", "keyword" },
			 { "msg", "keyword2" },		   { "block", "keyword2" },
			 { "tx", "keyword2" },		   { "now", "keyword2" },
			 { "this", "keyword2" },	   { "super", "keyword2" },
			 { "require", "keyword" },	   { "assert", "keyword2" },
			 { "revert", "keyword2" },	   { "selfdestruct", "keyword2" },
			 { "suicide", "keyword2" },	   { "addmod", "keyword2" },
			 { "mulmod", "keyword2" },	   { "keccak256", "keyword2" },
			 { "sha256", "keyword2" },	   { "sha3", "keyword2" },
			 { "ripemd160", "keyword2" },  { "ecrecover", "keyword2" },
			 { "blockhash", "keyword2" },  { "gasleft", "keyword2" },
			 { "contract", "keyword" },	   { "interface", "keyword" },
			 { "modifier", "keyword" },	   { "mapping", "keyword2" },
			 { "address", "keyword2" },	   { "string", "keyword2" },
			 { "byte", "keyword2" },	   { "bytes", "keyword2" },
			 { "bytes1", "keyword2" },	   { "bytes2", "keyword2" },
			 { "bytes3", "keyword2" },	   { "bytes4", "keyword2" },
			 { "bytes5", "keyword2" },	   { "bytes6", "keyword2" },
			 { "bytes7", "keyword2" },	   { "bytes8", "keyword2" },
			 { "bytes9", "keyword2" },	   { "bytes10", "keyword2" },
			 { "bytes11", "keyword2" },	   { "bytes12", "keyword2" },
			 { "bytes13", "keyword2" },	   { "bytes14", "keyword2" },
			 { "bytes15", "keyword2" },	   { "bytes16", "keyword2" },
			 { "bytes17", "keyword2" },	   { "bytes18", "keyword2" },
			 { "bytes19", "keyword2" },	   { "bytes20", "keyword2" },
			 { "bytes21", "keyword2" },	   { "bytes22", "keyword2" },
			 { "bytes23", "keyword2" },	   { "bytes24", "keyword2" },
			 { "bytes25", "keyword2" },	   { "bytes26", "keyword2" },
			 { "bytes27", "keyword2" },	   { "bytes28", "keyword2" },
			 { "bytes29", "keyword2" },	   { "bytes30", "keyword2" },
			 { "bytes31", "keyword2" },	   { "bytes32", "keyword2" },
			 { "int", "keyword2" },		   { "int8", "keyword2" },
			 { "int16", "keyword2" },	   { "int32", "keyword2" },
			 { "int64", "keyword2" },	   { "int128", "keyword2" },
			 { "int256", "keyword2" },	   { "uint", "keyword2" },
			 { "uint8", "keyword2" },	   { "uint16", "keyword2" },
			 { "uint32", "keyword2" },	   { "uint64", "keyword2" },
			 { "uint128", "keyword2" },	   { "uint256", "keyword2" },
			 { "bool", "keyword2" },	   { "hash", "keyword2" },
			 { "pragma", "keyword2" },	   { "using", "keyword" },
			 { "is", "keyword" },		   { "new", "keyword" },
			 { "delete", "keyword" },	   { "emit", "keyword" },
			 { "struct", "keyword" },	   { "protected", "keyword" } } } );

	// Objective-C
	add( { "Objective-C",
		   { "%.m$" },
		   { { { "//.-\n" }, "comment" },
			 { { "/%*", "%*/" }, "comment" },
			 { { "#", "[^\\]\n" }, "comment" },
			 { { "\"", "\"", "\\" }, "string" },
			 { { "'", "'", "\\" }, "string" },
			 { { "-?0x%x+" }, "number" },
			 { { "-?%d+[%d%.eE]*f?" }, "number" },
			 { { "-?%.?%d+f?" }, "number" },
			 { { "[%+%-=/%*%^%%<>!~|&]" }, "operator" },
			 { { "[%a_][%w_]*%f[(]" }, "function" },
			 { { "@[%a_][%w_]*" }, "keyword2" },
			 { { "[%a_][%w_]*" }, "symbol" } },
		   { { "if", "keyword" },	   { "then", "keyword" },	 { "else", "keyword" },
			 { "elseif", "keyword" },  { "do", "keyword" },		 { "while", "keyword" },
			 { "for", "keyword" },	   { "break", "keyword" },	 { "continue", "keyword" },
			 { "return", "keyword" },  { "goto", "keyword" },	 { "struct", "keyword" },
			 { "union", "keyword" },   { "typedef", "keyword" }, { "enum", "keyword" },
			 { "extern", "keyword" },  { "static", "keyword" },	 { "volatile", "keyword" },
			 { "const", "keyword" },   { "inline", "keyword" },	 { "switch", "keyword" },
			 { "case", "keyword" },	   { "default", "keyword" }, { "auto", "keyword" },
			 { "const", "keyword" },   { "void", "keyword" },	 { "int", "keyword2" },
			 { "short", "keyword2" },  { "long", "keyword2" },	 { "float", "keyword2" },
			 { "double", "keyword2" }, { "char", "keyword2" },	 { "unsigned", "keyword2" },
			 { "bool", "keyword2" },   { "true", "literal" },	 { "false", "literal" },
			 { "NULL", "literal" },	   { "nil", "literal" } },
		   "//" } );

	// Dart
	add( { "Dart",
		   { "%.dart$" },
		   {
			   { { "//.-\n" }, "comment" },
			   { { "///.-\n" }, "comment" },
			   { { "/%*", "%*/" }, "comment" },
			   { { "\"", "\"", "\\" }, "string" },
			   { { "'", "'", "\\" }, "string" },
			   { { "-?0x%x+" }, "number" },
			   { { "-?%d+[%d%.eE]*f?" }, "number" },
			   { { "-?%.?%d+f?" }, "number" },
			   { { "[%+%-=/%*%^%%<>!~|&]" }, "operator" },
			   { { "%?%?" }, "operator" },
			   { { "%?%." }, "operator" },
			   { { "[%$%@]?\"", "\"", "\\" }, "string" },
			   { { "'\\x%x?%x?%x?%x'" }, "string" },
			   { { "[%a_][%w_]*%f[(]" }, "function" },
			   { { "[%a_][%w_]*" }, "symbol" },
		   },
		   { { "await", "keyword" },	{ "bool", "keyword2" },	   { "break", "keyword" },
			 { "case", "keyword" },		{ "class", "keyword" },	   { "const", "keyword" },
			 { "continue", "keyword" }, { "default", "keyword" },  { "do", "keyword" },
			 { "double", "keyword2" },	{ "dynamic", "keyword2" }, { "else", "keyword" },
			 { "enum", "keyword" },		{ "false", "literal" },	   { "final", "keyword" },
			 { "finally", "keyword" },	{ "for", "keyword" },	   { "Function", "keyword2" },
			 { "if", "keyword" },		{ "in", "keyword" },	   { "int", "keyword2" },
			 { "List", "keyword2" },	{ "Map", "keyword2" },	   { "new", "keyword" },
			 { "null", "literal" },		{ "part of", "keyword" },  { "print", "keyword" },
			 { "return", "keyword" },	{ "static", "keyword" },   { "String", "keyword2" },
			 { "switch", "keyword" },	{ "then", "keyword" },	   { "this", "keyword2" },
			 { "true", "literal" },		{ "void", "keyword" },	   { "while", "keyword" } },
		   "//" } );

	// Add Kotlin
	add( { "Kotlin",
		   { "%.kt$" },
		   {
			   { { "//.-\n" }, "comment" },
			   { { "/%*", "%*/" }, "comment" },
			   { { "\"", "\"", "\\" }, "string" },
			   { { "'", "'", "\\" }, "string" },
			   { { "'\\x%x?%x?%x?%x'" }, "string" },
			   { { "'\\u%x%x%x%x'" }, "string" },
			   { { "'\\?.'" }, "string" },
			   { { "-?0x%x+" }, "number" },
			   { { "-?%d+[%d%.eE]*f?" }, "number" },
			   { { "-?%.?%d+f?" }, "number" },
			   { { "[%+%-=/%*%^%%<>!~|&]" }, "operator" },
			   { { "%@[%a_][%w_]*" }, "function" },
			   { { "[%a_][%w_]*%f[(]" }, "function" },
			   { { "[%a_][%w_]*" }, "symbol" },
		   },
		   { { "if", "keyword" },		   { "then", "keyword" },
			 { "else", "keyword" },		   { "elseif", "keyword" },
			 { "do", "keyword" },		   { "while", "keyword" },
			 { "for", "keyword" },		   { "new", "keyword" },
			 { "break", "keyword" },	   { "continue", "keyword" },
			 { "return", "keyword" },	   { "goto", "keyword" },
			 { "class", "keyword" },	   { "implements", "keyword" },
			 { "extends", "keyword" },	   { "private", "keyword" },
			 { "protected", "keyword" },   { "public", "keyword" },
			 { "abstract", "keyword" },	   { "interface", "keyword" },
			 { "assert", "keyword" },	   { "import", "keyword" },
			 { "native", "keyword" },	   { "package", "keyword" },
			 { "super", "keyword" },	   { "synchronized", "keyword" },
			 { "instanceof", "keyword" },  { "enum", "keyword" },
			 { "catch", "keyword" },	   { "throw", "keyword" },
			 { "throws", "keyword" },	   { "try", "keyword" },
			 { "transient", "keyword" },   { "finally", "keyword" },
			 { "static", "keyword" },	   { "volatile", "keyword" },
			 { "final", "keyword" },	   { "switch", "keyword" },
			 { "case", "keyword" },		   { "default", "keyword" },
			 { "void", "keyword" },		   { "Int", "keyword2" },
			 { "Short", "keyword2" },	   { "Byte", "keyword2" },
			 { "Long", "keyword2" },	   { "Float", "keyword2" },
			 { "Double", "keyword2" },	   { "String", "keyword2" },
			 { "Boolean", "keyword2" },	   { "true", "literal" },
			 { "false", "literal" },	   { "null", "literal" },
			 { "var", "keyword" },		   { "lateinit", "literal" },
			 { "override", "keyword" },	   { "fun", "keyword" },
			 { "sealed", "keyword" },	   { "companion", "keyword" },
			 { "object", "keyword" },	   { "val", "keyword" },
			 { "UInt", "keyword2" },	   { "UShort", "keyword2" },
			 { "UByte", "keyword2" },	   { "ULong", "keyword2" },
			 { "IntArray", "keyword2" },   { "ShortArray", "keyword2" },
			 { "ByteArray", "keyword2" },  { "LongArray", "keyword2" },
			 { "UIntArray", "keyword2" },  { "UShortArray", "keyword2" },
			 { "UByteArray", "keyword2" }, { "ULongArray", "keyword2" },
			 { "Array", "keyword2" } },
		   "//" } );
}

SyntaxDefinition& SyntaxDefinitionManager::add( SyntaxDefinition&& syntaxStyle ) {
	mStyles.emplace_back( std::move( syntaxStyle ) );
	return mStyles.back();
}

const SyntaxDefinition& SyntaxDefinitionManager::getPlainStyle() const {
	return mStyles[0];
}

SyntaxDefinition& SyntaxDefinitionManager::getStyleByExtensionRef( const std::string& filePath ) {
	return const_cast<SyntaxDefinition&>( getStyleByExtension( filePath ) );
}

const SyntaxDefinition&
SyntaxDefinitionManager::getStyleByLanguageName( const std::string& name ) const {
	for ( auto& style : mStyles ) {
		if ( style.getLanguageName() == name )
			return style;
	}
	return mStyles[0];
}

const SyntaxDefinition&
SyntaxDefinitionManager::getStyleByLanguageId( const String::HashType& id ) const {
	for ( auto& style : mStyles ) {
		if ( style.getLanguageId() == id )
			return style;
	}
	return mStyles[0];
}

SyntaxDefinition& SyntaxDefinitionManager::getStyleByLanguageNameRef( const std::string& name ) {
	return const_cast<SyntaxDefinition&>( getStyleByLanguageName( name ) );
}

std::vector<std::string> SyntaxDefinitionManager::getLanguageNames() const {
	std::vector<std::string> names;
	for ( auto& style : mStyles ) {
		names.push_back( style.getLanguageName() );
	}
	std::sort( names.begin(), names.end() );
	return names;
}

std::vector<std::string> SyntaxDefinitionManager::getExtensionsPatternsSupported() const {
	std::vector<std::string> exts;
	for ( auto& style : mStyles )
		for ( auto& pattern : style.getFiles() )
			exts.emplace_back( pattern );
	return exts;
}

const SyntaxDefinition&
SyntaxDefinitionManager::getStyleByExtension( const std::string& filePath ) const {
	std::string extension( FileSystem::fileExtension( filePath ) );

	// Use the filename instead
	if ( extension.empty() ) {
		extension = FileSystem::fileNameFromPath( filePath );
	}

	if ( !extension.empty() ) {
		for ( auto style = mStyles.rbegin(); style != mStyles.rend(); ++style ) {
			for ( const auto& ext : style->getFiles() ) {
				if ( String::startsWith( ext, "%." ) || String::endsWith( ext, "$" ) ) {
					LuaPattern words( ext );
					int start, end;
					if ( words.find( filePath, start, end ) ) {
						return *style;
					}
				} else if ( extension == ext ) {
					return *style;
				}
			}
		}
	}
	return mStyles[0];
}

const SyntaxDefinition&
SyntaxDefinitionManager::getStyleByHeader( const std::string& header ) const {
	if ( !header.empty() ) {
		for ( auto style = mStyles.rbegin(); style != mStyles.rend(); ++style ) {
			for ( const auto& hdr : style->getHeaders() ) {
				LuaPattern words( hdr );
				int start, end;
				if ( words.find( header, start, end ) ) {
					return *style;
				}
			}
		}
	}
	return mStyles[0];
}

const SyntaxDefinition& SyntaxDefinitionManager::find( const std::string& filePath,
													   const std::string& header ) {
	const SyntaxDefinition& def = getStyleByHeader( header );
	if ( def.getLanguageName() == mStyles[0].getLanguageName() )
		return getStyleByExtension( filePath );
	return def;
}
}}} // namespace EE::UI::Doc
